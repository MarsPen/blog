<h1 align="center">ğŸ“–ç¼–è¯‘è§£æåˆ†æ</h1>

## ç¼–è¯‘å…¥å£

åœ¨æ‰§è¡Œçš„è¿‡ç¨‹ä¸­ï¼Œ$mount è¿™ä¸ªå‡½æ•°å†…è°ƒç”¨ compileToFunctions å—ï¼Ÿä¸‹é¢æˆ‘ä»¬å†æ¥çœ‹çœ‹è¿™ä¸ªæ–¹æ³•

```js
// ...
  const { render, staticRenderFns } = compileToFunctions(template, {
    shouldDecodeNewlines,
    shouldDecodeNewlinesForHref,
    delimiters: options.delimiters,
    comments: options.comments
  }, this)
  options.render = render
  options.staticRenderFns = staticRenderFns
// ...
```

compileToFunctions æ¥è‡³äº `src/compiler/index.js` ä¸­  createCompiler(baseOptions) 

```js

// createCompilerCreator å…è®¸åˆ›å»ºä½¿ç”¨alternativeçš„ç¼–è¯‘å™¨
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// è¿™é‡Œæˆ‘ä»¬åªæ˜¯ä½¿ç”¨é»˜è®¤éƒ¨åˆ†å¯¼å‡ºä¸€ä¸ªé»˜è®¤ç¼–è¯‘å™¨
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```

### createCompilerCreator <hr>

createCompilerCreator æ¥è‡³äº `src/compiler/create-compiler.js`ä¸­

```js
export function createCompilerCreator (baseCompile: Function): Function {
  return function createCompiler (baseOptions: CompilerOptions) {
    function compile (
      template: string,
      options?: CompilerOptions
    ): CompiledResult {
      const finalOptions = Object.create(baseOptions)
      const errors = []
      const tips = []
      finalOptions.warn = (msg, tip) => {
        (tip ? tips : errors).push(msg)
      }

      if (options) {
        // åˆå¹¶è‡ªå®šä¹‰æ¨¡å—
        if (options.modules) {
          finalOptions.modules =
            (baseOptions.modules || []).concat(options.modules)
        }
        // åˆå¹¶è‡ªå®šä¹‰æŒ‡ä»¤
        if (options.directives) {
          finalOptions.directives = extend(
            Object.create(baseOptions.directives || null),
            options.directives
          )
        }
        // å¤åˆ¶å…¶ä»–å‚æ•°
        for (const key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key]
          }
        }
      }

      const compiled = baseCompile(template, finalOptions)
      if (process.env.NODE_ENV !== 'production') {
        errors.push.apply(errors, detectErrors(compiled.ast))
      }
      compiled.errors = errors
      compiled.tips = tips
      return compiled
    }

    return {
      compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    }
  }
}
```

è¯¥æ–¹æ³•è¿”å›äº†ä¸€ä¸ª createCompiler çš„å‡½æ•°ï¼Œå®ƒæ¥æ”¶ä¸€ä¸ª baseOptions çš„å‚æ•°ï¼Œè¿”å›çš„æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼ŒåŒ…æ‹¬ compile æ–¹æ³•å±æ€§å’Œ compileToFunctions å±æ€§ï¼Œè¿™ä¸ª compileToFunctions å¯¹åº”çš„å°±æ˜¯ $mount å‡½æ•°è°ƒç”¨çš„ compileToFunctions æ–¹æ³•ï¼Œå®ƒæ˜¯è°ƒç”¨ createCompileToFunctionFn æ–¹æ³•çš„è¿”å›å€¼ã€‚

### createCompileToFunctionFn <hr>

æˆ‘ä»¬æ¥ä¸‹æ¥çœ‹ä¸€ä¸‹ createCompileToFunctionFn æ–¹æ³•ï¼Œå®ƒçš„å®šä¹‰åœ¨ `src/compiler/to-function/js` ä¸­

```js
export function createCompileToFunctionFn (compile: Function): Function {
  const cache = Object.create(null)

  return function compileToFunctions (
    template: string,
    options?: CompilerOptions,
    vm?: Component
  ): CompiledFunctionResult {
    options = extend({}, options)
    const warn = options.warn || baseWarn
    delete options.warn

    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      // detect possible CSP restriction
      try {
        new Function('return 1')
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn(
            'It seems you are using the standalone build of Vue.js in an ' +
            'environment with Content Security Policy that prohibits unsafe-eval. ' +
            'The template compiler cannot work in this environment. Consider ' +
            'relaxing the policy to allow unsafe-eval or pre-compiling your ' +
            'templates into render functions.'
          )
        }
      }
    }

    // check cache
    const key = options.delimiters
      ? String(options.delimiters) + template
      : template
    if (cache[key]) {
      return cache[key]
    }

    // ç¼–è¯‘
    const compiled = compile(template, options)

    // æ£€æŸ¥ç¼–è¯‘é”™è¯¯/æç¤º
    if (process.env.NODE_ENV !== 'production') {
      if (compiled.errors && compiled.errors.length) {
        warn(
          `Error compiling template:\n\n${template}\n\n` +
          compiled.errors.map(e => `- ${e}`).join('\n') + '\n',
          vm
        )
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(msg => tip(msg, vm))
      }
    }

    // å°†ä»£ç è½¬æ¢ä¸ºå‡½æ•°
    const res = {}
    const fnGenErrors = []
    res.render = createFunction(compiled.render, fnGenErrors)
    res.staticRenderFns = compiled.staticRenderFns.map(code => {
      return createFunction(code, fnGenErrors)
    })

    // æ£€æŸ¥å‡½æ•°ç”Ÿæˆé”™è¯¯.
    // åªæœ‰å½“ç¼–è¯‘å™¨æœ¬èº«å­˜åœ¨é”™è¯¯æ—¶ï¼Œæ‰ä¼šå‘ç”Ÿè¿™ç§æƒ…å†µ
    // ä¸»è¦ç”¨äºcodegen å¼€å‘ä½¿ç”¨
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production') {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn(
          `Failed to generate render function:\n\n` +
          fnGenErrors.map(({ err, code }) => `${err.toString()} in\n\n${code}\n`).join('\n'),
          vm
        )
      }
    }

    return (cache[key] = res)
  }
```

### compile<hr>

é€šè¿‡ä¸Šé¢å‡½æ•°æˆ‘ä»¬çœ‹åˆ° compileToFunctions æ¥æ”¶ä¸‰ä¸ªå‚æ•°ï¼Œç¼–è¯‘æ¨¡æ¿ templateï¼Œç¼–è¯‘é…ç½® options å’Œ Vue å®ä¾‹ vmã€‚æ ¸å¿ƒä»£ç åªæœ‰ä¸€è¡Œ

```js
const compiled = compile(template, options)
```

### baseCompile<hr>

compile å‡½æ•°æ‰§è¡Œçš„é€»è¾‘æ˜¯å…ˆå¤„ç†é…ç½®å‚æ•°ï¼ŒçœŸæ­£æ‰§è¡Œç¼–è¯‘è¿‡ç¨‹å°±ä¸€è¡Œä»£ç ï¼š

```js
const compiled = baseCompile(template, finalOptions)
```

baseCompile æ˜¯åœ¨æ‰§è¡Œ createCompilerCreator æ–¹æ³•æ—¶ä½œä¸ºå‚æ•°ä¼ å…¥çš„æ‰€ä»¥ç»•äº†ä¸€åœˆçœŸæ­£çš„å…¥å£å°±æ˜¯

```js
// `createCompilerCreator`å…è®¸åˆ›å»ºä½¿ç”¨alternativeçš„ç¼–è¯‘å™¨
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// è¿™é‡Œæˆ‘ä»¬åªæ˜¯ä½¿ç”¨é»˜è®¤éƒ¨åˆ†å¯¼å‡ºä¸€ä¸ªé»˜è®¤ç¼–è¯‘å™¨
export const createCompiler = createCompilerCreator(function baseCompile (
  template: string,
  options: CompilerOptions
): CompiledResult {
  const ast = parse(template.trim(), options)
  if (options.optimize !== false) {
    optimize(ast, options)
  }
  const code = generate(ast, options)
  return {
    ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  }
})
```
### ä¸»è¦æ‰§è¡Œæ­¥éª¤<hr>

> è§£ææ¨¡æ¿å­—ç¬¦ä¸²ç”Ÿæˆ AST

```js
const ast = parse(template.trim(), options)
```

> ä¼˜åŒ–è¯­æ³•æ ‘

```js
optimize(ast, options)
```

> ç”Ÿæˆä»£ç 

```js
const code = generate(ast, options)
```


## parse

parse å®šä¹‰åœ¨ `src/compiler/parser/index.js` ä¸­ï¼Œç”±äºç¼–è¯‘æµç¨‹è¾ƒä¸ºå¤æ‚éš¾æ‡‚æ‰€ä»¥æˆ‘ä»¬åªäº†è§£å¤§æ¦‚çš„æµç¨‹

parse æ¥æ”¶ä¸¤ä¸ªå‚æ•° template å’Œ options å¯¹äº options ä¸å»ç ”ç©¶å¹³å°ç‰¹æ®Šæ€§ï¼Œtemplate æ¨¡æ¿çš„è§£æä¸»è¦æ˜¯é€šè¿‡ parseHTML å‡½æ•°å¾ªç¯è§£æ

```js
parseHTML(template, options)
```

å¯¹äºä¸åŒæƒ…å†µåˆ†åˆ«è¿›è¡Œä¸åŒçš„å¤„ç†ï¼Œåœ¨åŒ¹é…çš„è¿‡ç¨‹ä¸­ä¼šåˆ©ç”¨ advance å‡½æ•°ä¸æ–­å‰è¿›æ•´ä¸ªæ¨¡æ¿å­—ç¬¦ä¸²ï¼Œç›´åˆ°å­—ç¬¦ä¸²æœ«å°¾ã€‚

```js
function advance (n) {
  index += n
  html = html.substring(n)
}
```

- å¯¹äºæ³¨é‡Šå’Œæ¡ä»¶æ³¨é‡ŠèŠ‚ç‚¹ï¼Œå‰è¿›è‡³å®ƒä»¬çš„æœ«å°¾ä½ç½®ï¼›å¯¹äºæ–‡æ¡£ç±»å‹èŠ‚ç‚¹ï¼Œåˆ™å‰è¿›å®ƒè‡ªèº«é•¿åº¦çš„è·ç¦»
- é€šè¿‡ parseStartTag è§£æå¼€å§‹æ ‡ç­¾(é€šè¿‡ startTagOpené…ç½®å¼€å§‹æ ‡ç­¾ï¼Œç„¶åå®šä¹‰äº† match å¯¹è±¡ï¼Œé€šè¿‡ handleStartTag å¤„ç† match.attrs,æœ€åè°ƒç”¨ options.startå›è°ƒå‡½æ•°)
- é€šè¿‡æ­£åˆ™ endTag åŒ¹é…åˆ°é—­åˆæ ‡ç­¾ï¼Œç„¶åå‰è¿›åˆ°é—­åˆæ ‡ç­¾æœ«å°¾ï¼Œç„¶åæ‰§è¡Œ parseEndTag æ–¹æ³•å¯¹é—­åˆï¼Œæœ€åè°ƒç”¨ options.end å›è°ƒå‡½æ•°
- åˆ¤æ–­ textEnd æ˜¯å¦å¤§äºç­‰äº 0 è¯´æ˜ä»å½“å‰ä½ç½®åˆ° textEnd ä½ç½®éƒ½æ˜¯æ–‡æœ¬ï¼Œå¦‚æœ extEnd å°äº 0 çš„æƒ…å†µï¼Œåˆ™è¯´æ˜æ•´ä¸ª template è§£æå®Œæ¯•äº†ï¼Œå°†å‰©ä½™çš„ html éƒ½èµ‹å€¼ç»™äº† textï¼Œæœ€åè°ƒç”¨äº† options.chars å›è°ƒå‡½æ•°ï¼Œå¹¶ä¼  text å‚æ•°

### options.start å¤„ç†å¼€å§‹æ ‡ç­¾<hr>

```js
// ...
start (tag, attrs, unary) {
  let element = createASTElement(tag, attrs)
  processElement(element)
  treeManagement()
}
// ...
```
- é€šè¿‡ createASTElement åˆ›å»º AST å…ƒç´ 
- å¤„ç† AST å…ƒç´ 
- AST æ ‘ç®¡ç†

> createASTElement

```js
// ...
// æ¯ä¸€ä¸ª AST å…ƒç´ æ˜¯ä¸€ä¸ªæ™®é€šçš„ JavaScript å¯¹è±¡
// type è¡¨ç¤º AST å…ƒç´ ç±»å‹
// tag è¡¨ç¤ºæ ‡ç­¾å
// attrsList è¡¨ç¤ºå±æ€§åˆ—è¡¨
// attrsMap è¡¨ç¤ºå±æ€§æ˜ å°„è¡¨
// parent è¡¨ç¤ºçˆ¶çš„ AST å…ƒç´ 
// children è¡¨ç¤ºå­ AST å…ƒç´ é›†åˆã€‚
export function createASTElement (
  tag: string,
  attrs: Array<Attr>,
  parent: ASTElement | void
): ASTElement {
  return {
    type: 1,
    tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent,
    children: []
  }
}
// ...
```
> processElement(element)

è°ƒç”¨ preTransformsã€transformsã€postTransforms å‡½ï¼Œç„¶åé€šè¿‡å„ç§æŒ‡ä»¤ processXXX åšå¤„ç†ï¼Œå¤„ç†çš„ç»“æœå°±æ˜¯æ‰©å±• AST å…ƒç´ çš„å±æ€§ï¼Œå¦‚ processFor è§£æ v-for æŒ‡ä»¤å†…å®¹ï¼Œå°†è§£æçš„å±æ€§å€¼æ·»åŠ åˆ° AST çš„å…ƒç´ ä¸Š

> treeManagement()

AST æ ‘ç®¡ç†çš„ç›®æ ‡æ˜¯æ„å»ºä¸€é¢— AST æ ‘ï¼Œæœ¬è´¨ä¸Šåˆ©ç”¨ stack æ ˆçš„æ•°æ®ç»“æ„æ¥ç»´æŠ¤ root æ ¹èŠ‚ç‚¹å’Œå½“å‰çˆ¶èŠ‚ç‚¹ currentParentã€‚



### options.end å¤„ç†é—­åˆæ ‡ç­¾<hr>

```js
end () {
  treeManagement()
  closeElement()
}
```

> é¦–å…ˆå¤„ç†äº†å°¾éƒ¨ç©ºæ ¼çš„æƒ…å†µ,ç„¶åæŠŠ stack çš„å…ƒç´ å¼¹ä¸€ä¸ªå‡ºæ ˆï¼Œå¹¶æŠŠ stack æœ€åä¸€ä¸ªå…ƒç´ èµ‹å€¼ç»™ currentParentï¼Œè¿™æ ·å°±ç»´æŠ¤äº†æ•´ä¸ª AST æ ‘ã€‚

```js
// remove trailing whitespace
const element = stack[stack.length - 1]
const lastNode = element.children[element.children.length - 1]
if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
  element.children.pop()
}
// pop stack
stack.length -= 1
currentParent = stack[stack.length - 1]
closeElement(element)
```

> closeElement æ›´æ–°ä¸€ä¸‹ inVPre å’Œ inPre çš„çŠ¶æ€ï¼Œä»¥åŠæ‰§è¡Œ postTransforms å‡½æ•° 

```js
function closeElement (element) {
  // check pre state
  if (element.pre) {
    inVPre = false
  }
  if (platformIsPreTag(element.tag)) {
    inPre = false
  }
  // apply post-transforms
  for (let i = 0; i < postTransforms.length; i++) {
    postTransforms[i](element, options)
  }
}
```

### options.chars å¤„ç†æ–‡æœ¬å†…å®¹<hr>

```js
chars (text: string) {
  handleText()
  createChildrenASTOfText()
}
```

é€šè¿‡æ‰§è¡Œ parseText(text, delimiters) å¯¹æ–‡æœ¬è§£æ, å®šä¹‰åœ¨ `src/compiler/parser/text-parsre.js` ä¸­ï¼Œä¸»è¦æµç¨‹å°±æ˜¯

```js

// å…ˆæ ¹æ®åˆ†éš”ç¬¦ï¼ˆé»˜è®¤æ˜¯ `{{}}`ï¼‰æ„é€ äº†æ–‡æœ¬åŒ¹é…çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œç„¶åå†å¾ªç¯åŒ¹é…æ–‡æœ¬
// é‡åˆ°æ™®é€šæ–‡æœ¬å°± push åˆ° rawTokens å’Œ tokens ä¸­
// å¦‚æœæ˜¯è¡¨è¾¾å¼å°±è½¬æ¢æˆ `_s(${exp})` push åˆ° tokens ä¸­
// è½¬æ¢æˆ `{@binding:exp}` push åˆ° rawTokens ä¸­

const defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g
const regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g

const buildRegex = cached(delimiters => {
  const open = delimiters[0].replace(regexEscapeRE, '\\$&')
  const close = delimiters[1].replace(regexEscapeRE, '\\$&')
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g')
})

export function parseText (
  text: string,
  delimiters?: [string, string]
): TextParseResult | void {
  const tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE
  if (!tagRE.test(text)) {
    return
  }
  const tokens = []
  const rawTokens = []
  let lastIndex = tagRE.lastIndex = 0
  let match, index, tokenValue
  while ((match = tagRE.exec(text))) {
    index = match.index
    // push text token
    if (index > lastIndex) {
      rawTokens.push(tokenValue = text.slice(lastIndex, index))
      tokens.push(JSON.stringify(tokenValue))
    }
    // tag token
    const exp = parseFilters(match[1].trim())
    tokens.push(`_s(${exp})`)
    rawTokens.push({ '@binding': exp })
    lastIndex = index + match[0].length
  }
  if (lastIndex < text.length) {
    rawTokens.push(tokenValue = text.slice(lastIndex))
    tokens.push(JSON.stringify(tokenValue))
  }
  return {
    expression: tokens.join('+'),
    tokens: rawTokens
  }
}
```

### å°ç»“ <hr>

- parse çš„ä½œç”¨å°±æ˜¯å°† template æ¨¡ç‰ˆå­—ç¬¦ä¸²è½¬æ¢æˆ AST æ ‘ã€‚å…¶å®æ˜¯ç”¨å¯¹è±¡çš„å½¢å¼æ¥æè¿°æ•´ä¸ªæ¨¡ç‰ˆï¼Œç”¨æ­£åˆ™é¡ºåºè§£ææ¨¡ç‰ˆï¼Œè¾¾åˆ°æ„å»º AST æ ‘çš„ç›®çš„
- AST å…ƒç´ èŠ‚ç‚¹æ€»å…±æœ‰ 3 ç§ç±»å‹ï¼Œtype ä¸º 1 è¡¨ç¤ºæ˜¯æ™®é€šå…ƒç´ ï¼Œä¸º 2 è¡¨ç¤ºæ˜¯è¡¨è¾¾å¼ï¼Œä¸º 3 è¡¨ç¤ºæ˜¯çº¯æ–‡æœ¬


## optimize

optimize æ–¹æ³•çš„å®šä¹‰ï¼Œåœ¨ `src/compiler/optimizer.js` ä¸­

```js
export function optimize (root: ?ASTElement, options: CompilerOptions) {
  if (!root) return
  isStaticKey = genStaticKeysCached(options.staticKeys || '')
  isPlatformReservedTag = options.isReservedTag || no
  // first pass: mark all non-static nodes.
  markStatic(root)
  // second pass: mark static roots.
  markStaticRoots(root, false)
}

function genStaticKeys (keys: string): Function {
  return makeMap(
    'type,tag,attrsList,attrsMap,plain,parent,children,attrs' +
    (keys ? ',' + keys : '')
  )
}
```

é€šè¿‡ optimize å‡½æ•°æˆ‘ä»¬çœ‹åˆ°ä¼˜åŒ–ä¸»è¦å°±åšäº†ä¸¤ä»¶äº‹æƒ…

### markStatic(root) æ ‡è®°é™æ€èŠ‚ç‚¹<hr>

```js
function markStatic (node: ASTNode) {
  node.static = isStatic(node)
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (
      !isPlatformReservedTag(node.tag) &&
      node.tag !== 'slot' &&
      node.attrsMap['inline-template'] == null
    ) {
      return
    }
    for (let i = 0, l = node.children.length; i < l; i++) {
      const child = node.children[i]
      markStatic(child)
      if (!child.static) {
        node.static = false
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        const block = node.ifConditions[i].block
        markStatic(block)
        if (!block.static) {
          node.static = false
        }
      }
    }
  }
}

function isStatic (node: ASTNode): boolean {
  if (node.type === 2) { // expression
    return false
  }
  if (node.type === 3) { // text
    return true
  }
  return !!(node.pre || (
    !node.hasBindings && // no dynamic bindings
    !node.if && !node.for && // not v-if or v-for or v-else
    !isBuiltInTag(node.tag) && // not a built-in
    isPlatformReservedTag(node.tag) && // not a component
    !isDirectChildOfTemplateFor(node) &&
    Object.keys(node).every(isStaticKey)
  ))
}
```
- é€šè¿‡ isStatic å‡½æ•°åˆ¤æ–­ AST æ˜¯å¦æ˜¯é™æ€
- type === 2 ä¸ºè¡¨è¾¾å¼ä¸æ˜¯é™æ€
- type === 3 æ˜¯çº¯æ–‡æœ¬æ˜¯é™æ€
- æ™®é€šå…ƒç´ ï¼Œå¦‚æœæœ‰ pre å±æ€§ æ˜¯é™æ€
- æ²¡æœ‰ä½¿ç”¨ v-ifã€ v-for ã€æ²¡æœ‰ä½¿ç”¨å…¶å®ƒæŒ‡ä»¤ï¼ˆä¸åŒ…æ‹¬ v-onceï¼‰ã€éå†…ç½®ç»„ä»¶ã€æ˜¯å¹³å°ä¿ç•™çš„æ ‡ç­¾ã€èŠ‚ç‚¹çš„æ‰€æœ‰å±æ€§çš„ key éƒ½æ»¡è¶³é™æ€ keyï¼Œè¿™äº›éƒ½æ»¡è¶³åˆ™è¿™ä¸ª AST èŠ‚ç‚¹æ˜¯ä¸€ä¸ªé™æ€èŠ‚ç‚¹
- é€’å½’éå†æ™®é€šå…ƒç´ ï¼Œå¦‚æœä¸€æ—¦å­èŠ‚ç‚¹æœ‰ä¸æ˜¯é™æ€çš„æƒ…å†µï¼Œåˆ™çˆ¶èŠ‚ç‚¹çš„ static å˜ä¸º false

### markStaticRoots(root, false) æ ‡è®°é™æ€æ ¹<hr>

```js
function markStaticRoots (node: ASTNode, isInFor: boolean) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(
      node.children.length === 1 &&
      node.children[0].type === 3
    )) {
      node.staticRoot = true
      return
    } else {
      node.staticRoot = false
    }
    if (node.children) {
      for (let i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for)
      }
    }
    if (node.ifConditions) {
      for (let i = 1, l = node.ifConditions.length; i < l; i++) {
        markStaticRoots(node.ifConditions[i].block, isInFor)
      }
    }
  }
}
```

- å¯¹äºå·²ç»æ˜¯ static çš„èŠ‚ç‚¹æˆ–è€…æ˜¯ v-once æŒ‡ä»¤çš„èŠ‚ç‚¹ï¼Œnode.staticInFor = isInFor
- æœ¬èº«æ˜¯ä¸€ä¸ªé™æ€èŠ‚ç‚¹å¤–ï¼Œæ»¡è¶³æ‹¥æœ‰ childrenï¼Œå¹¶ä¸” children ä¸èƒ½åªæ˜¯ä¸€ä¸ªæ–‡æœ¬èŠ‚ç‚¹ï¼Œæ‰æœ‰èµ„æ ¼æˆä¸º staticRoot çš„èŠ‚ç‚¹
- é€’å½’éå†æ™®é€šå…ƒç´ ï¼Œå¦‚æœä¸€æ—¦å­èŠ‚ç‚¹æœ‰ä¸æ˜¯é™æ€çš„æƒ…å†µï¼Œåˆ™çˆ¶èŠ‚ç‚¹çš„ static å˜ä¸º false


### å°ç»“<hr>

optimize çš„è¿‡ç¨‹ï¼Œå°±æ˜¯æ·±åº¦éå†è¿™ä¸ª AST æ ‘ï¼Œæ£€æµ‹å®ƒçš„æ¯ä¸€é¢—å­æ ‘æ˜¯ä¸æ˜¯é™æ€èŠ‚ç‚¹ï¼Œå¦‚æœæ˜¯é™æ€èŠ‚ç‚¹åˆ™å®ƒä»¬ç”Ÿæˆ DOM æ°¸è¿œä¸éœ€è¦æ”¹å˜ï¼Œè¿™æ ·æˆ‘ä»¬åœ¨ patch çš„è¿‡ç¨‹å°±ä¸ä¼šå¯¹æ¯”ä¸ºé™æ€å±æ€§çš„èŠ‚ç‚¹


## codegen

æœ€åä¸€æ­¥å°±æ˜¯å°†ä¼˜åŒ–è¿‡åçš„ AST æ ‘è½¬åŒ–æˆæ‰§è¡Œçš„ä»£ç 

```js
const code = generate(ast, options)
```

generate å‡½æ•°çš„å®šä¹‰åœ¨ src/compiler/codegen/index.js ä¸­

```js
export function generate (
  ast: ASTElement | void,
  options: CompilerOptions
): CodegenResult {
  const state = new CodegenState(options)
  const code = ast ? genElement(ast, state) : '_c("div")'
  return {
    render: `with(this){return ${code}}`,
    staticRenderFns: state.staticRenderFns
  }
}
```
### CodegenState <hr>

è°ƒç”¨ CodegenState å‡½æ•°ï¼Œè·å–æ‰€æœ‰ modules ä¸­çš„ genData å‡½æ•°

### genElement <hr>

è°ƒç”¨ genElement å‡½æ•°ç”Ÿæˆ code

```js
export function genElement (el: ASTElement, state: CodegenState): string {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state)
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state)
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state)
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state)
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0'
  } else if (el.tag === 'slot') {
    return genSlot(el, state)
  } else {
    // component or element
    let code
    if (el.component) {
      code = genComponent(el.component, el, state)
    } else {
      const data = el.plain ? undefined : genData(el, state)

      const children = el.inlineTemplate ? null : genChildren(el, state, true)
      code = `_c('${el.tag}'${
        data ? `,${data}` : '' // data
      }${
        children ? `,${children}` : '' // children
      })`
    }
    // module transforms
    for (let i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code)
    }
    return code
  }
}
```

æ ¹æ® AST çš„å±æ€§æ‰§è¡Œä¸åŒçš„ä»£ç ç”Ÿæˆå‡½æ•°ï¼Œè¿™é‡Œé¢æœ‰ genStaticã€genOnceã€genForã€genIfã€genChildrenã€genSlotã€genDataã€genComponent

### æ‰§è¡Œ code <hr> 

ç”¨ `with(this){return ${code}}` å°† code ä¼ å…¥ render ä¸­æ‰§è¡Œ new Function()

```js
const compiled = compile(template, options)
res.render = createFunction(compiled.render, fnGenErrors)

function createFunction (code, errors) {
  try {
    return new Function(code)
  } catch (err) {
    errors.push({ err, code })
    return noop
  }
}
```

## æ€»ç»“

<img src="/assets/vue-dom-diff12.png"></img>



















