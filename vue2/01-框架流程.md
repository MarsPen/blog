
<h1 align="center">ğŸ“–æ¡†æ¶æµç¨‹åˆ†æ</h1>

vue ä¸€ç›´ä»¥ç®€å•ï¼Œå¿«é€Ÿè‘—ç§°ï¼Œä¹Ÿè‡ªç§°ä¸ºæ¸è¿›å¼æ¡†æ¶ä»Šå¤©æˆ‘ä»¬æ¥äº†è§£ä¸€ä¸‹ vue çš„æºç ï¼Œè¿™æ ·æˆ‘ä»¬ä¹Ÿèƒ½äº†è§£å…¶ä¸­çš„æ€æƒ³ï¼Œå¸®åŠ©æˆ‘ä»¬åœ¨å·¥ä½œä¸­å¾ˆå¥½çš„åº”ç”¨å’Œè§£å†³é—®é¢˜ã€‚


## æºç æ¶æ„

æˆ‘ä»¬çœ‹ä¸€ä¸‹ <a href="https://github.com/vuejs/vue">vueæºç </a> çš„æ ¸å¿ƒç›®å½•æ–¹ä¾¿å¤§å®¶å»å¯¹åº”æŸ¥æ‰¾

``` md
src
â”œâ”€â”€ compiler/        # æ¨¡ç‰ˆç¼–è¯‘ç›®å½• 
â”œâ”€â”€ core/            # æ ¸å¿ƒä»£ç  
â”œâ”€â”€ platforms/       # è·¨å¹³å°çš„æ”¯æŒ
â”œâ”€â”€ server/          # å¤„ç†æœåŠ¡ç«¯æ¸²æŸ“
â”œâ”€â”€ sfc/             # .vue æ–‡ä»¶çš„è§£æ
â”œâ”€â”€ shared/          # å…¨å±€ç”¨åˆ°çš„å·¥å…·å‡½æ•°
```

### compiler<hr>

vue æ‰€æœ‰ç¼–è¯‘ç›¸å…³çš„ä»£ç ã€‚åŒ…æ‹¬æŠŠæ¨¡ç‰ˆè§£ææˆæŠ½è±¡è¯­æ³•æ ‘ï¼ˆASTï¼‰,ç¼–è¯‘ã€ç”Ÿæˆç­‰åŠŸèƒ½

### core<hr>

vue æ ¸å¿ƒä»£ç ï¼ŒåŒ…æ‹¬å†…ç½®ç»„ä»¶ï¼ŒæŒ‡ä»¤ã€å…¨å±€APIã€Observerã€è™šæ‹ŸDOMã€å…¨å±€å·¥å…·å‡½æ•°ç­‰ï¼Œè¿™ä¸ªç›®å½•ä¹Ÿæ˜¯vueçš„çµé­‚ï¼Œä¹Ÿæ˜¯æˆ‘ä»¬é‡ç‚¹å…³æ³¨åˆ†æçš„åœ°æ–¹ï¼Œcompiler ä¼šåœ¨åç»­æ–‡ç« ä¸­åˆ†æ

###  platform<hr>

æœ€åˆ vue æ˜¯è·‘åœ¨ web ä¸Šçš„mvvmæ¶æ„, åæœŸå¢åŠ äº† é˜¿é‡Œå›¢é˜Ÿçš„ weex å…¥å£ï¼Œé…åˆ weex ä¹Ÿå¯ä»¥è¿è¡Œåœ¨ native å®¢æˆ·ç«¯ä¸Š

### server <hr>

æœåŠ¡ç«¯æ¸²æŸ“å…¥å£ï¼Œè¿™æ˜¯æ˜¯vue2.0 ä¹‹åæ›´æ–°çš„åŠŸèƒ½ï¼Œæ‰€è°“çš„æœåŠ¡ç«¯æ¸²æŸ“æ˜¯æŠŠç›¸å¯¹åº”çš„ç»„ä»¶æ¸²æŸ“ä¸ºæœåŠ¡ç«¯çš„ html å­—ç¬¦ä¸²ï¼Œç„¶åå‘é€ç»™å®¢æˆ·ç«¯ï¼Œå®¢æˆ·ç«¯è¿›è¡Œå¤„ç†ã€‚è¿™æ ·åšèƒ½æé«˜å®¢æˆ·ä½“éªŒ

### sfc<hr>

å°† .vue æ–‡ä»¶å†…å®¹è§£ææˆJavaScriptçš„å¯¹è±¡


## æºç æ„å»º

vue æºç æ˜¯åŸºäº <a href="https://rollupjs.org/guide/en/">Rollup </a>æ„å»ºçš„ï¼Œæ„å»ºçš„é…ç½®åœ¨ scripts ç›®å½•ä¸‹

``` md
scripts
â”œâ”€â”€ git-hook/           # git-hooké…ç½®æ–‡ä»¶
â”œâ”€â”€ alias               # æ··å…¥æ–‡ä»¶ç›®å½•åˆ«åé…ç½®
â”œâ”€â”€ build               # æ„å»ºçš„å…¥å£æ–‡ä»¶
â”œâ”€â”€ config              # æ„å»ºå…¨å±€é…ç½®æ–‡ä»¶
â”œâ”€â”€ feature-flags       # weex ç¯å¢ƒ flag
â”œâ”€â”€ gen-release-note    # ç”Ÿæˆ Change log
â”œâ”€â”€ get-weex-version    # ç”Ÿæˆ weexBaseVersion
â”œâ”€â”€ release-weex        # weexå‘å¸ƒçš„è„šæœ¬
â”œâ”€â”€ release             # å‘å¸ƒè„šæœ¬
â”œâ”€â”€ verify-commit-msg   # æ£€æŸ¥ Commit message æ˜¯å¦ç¬¦åˆæ ¼å¼
```

### æ„å»ºè„šæœ¬<hr>

åŸºäº npm æ‰˜ç®¡çš„é¡¹ç›®éƒ½ä¼šæœ‰ä¸€ä¸ª package.json æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶å½“ä¸­çš„ script æè¿°ç¬¦ä¸­ä¸€èˆ¬é…ç½®çš„åŸºæœ¬éƒ½æ˜¯å¯åŠ¨é¡¹ç›®ã€æ‰“åŒ…ã€æµ‹è¯•ç­‰ç›¸å…³å‘½ä»¤, çœ‹ä¸€ä¸‹ vue é¡¹ç›®æ ¹ç›®å½•çš„ package.json,ç”±äºåªåš build ç¯å¢ƒä¸­çš„åˆ†æï¼Œæ‰€ä»¥æˆ‘ä»¬å»æ‰ devã€testç­‰æ‰§è¡Œå‘½ä»¤

``` json
{
  "scripts": {
    "build": "node scripts/build.js",
    "build:ssr": "npm run build -- web-runtime-cjs,web-server-renderer",
    "build:weex": "npm run build -- weex",
  } 
}
```


ä¸Šé¢ä¸‰ä¸ªå‘½ä»¤åœ¨æ‰§è¡Œçš„æ—¶å€™é€šè¿‡ç¯å¢ƒå‚æ•°æ¥åŒºåˆ†ä¸åŒçš„å¹³å°ï¼Œå½“æ‰§è¡Œ `npm run build` å‘½ä»¤çš„æ—¶å€™å°±ä¼šæ‰§è¡Œ `node scripts/build.js` è¿™ä¸ªæ–‡ä»¶

### æ„å»ºè¿‡ç¨‹<hr>

æ¥ä¸‹æ¥æ¥æŸ¥çœ‹ä¸€ä¸‹ `node scripts/build.js` è¿™ä¸ªæ–‡ä»¶çœ‹çœ‹æ‰§è¡Œè¿‡ç¨‹

```js
let builds = require('./config').getAllBuilds()
// filter builds via command line arg
if (process.argv[2]) {
  const filters = process.argv[2].split(',')
  builds = builds.filter(b => {
    return filters.some(f => b.output.file.indexOf(f) > -1 || b._name.indexOf(f) > -1)
  })
} else {
  // filter out weex builds by default
  builds = builds.filter(b => {
    return b.output.file.indexOf('weex') === -1
  })
}

build(builds)
// ...


```

é€šè¿‡ä¸Šé¢çš„ä»£ç ç‰‡æ®µäº†è§£åˆ°ä¸»è¦å¼•ç”¨äº† `./config` getAllBuilds æ–‡ä»¶ä¸‹é¢çš„æ–¹æ³•ï¼Œè¿›å…¥è¿™ä¸ªæ–‡ä»¶

```js
const builds = {
  // ...

  const aliases = require('./alias')
  const resolve = p => {
    const base = p.split('/')[0]
    if (aliases[base]) {
      return path.resolve(aliases[base], p.slice(base.length + 1))
    } else {
      return path.resolve(__dirname, '../', p)
    }
  }


  // Runtime only (CommonJS). Used by bundlers e.g. Webpack & Browserify
  'web-runtime-cjs-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.common.prod.js'),
    format: 'cjs',
    env: 'production',
    banner
  },
  // runtime-only production build (Browser)
  'web-runtime-prod': {
    entry: resolve('web/entry-runtime.js'),
    dest: resolve('dist/vue.runtime.min.js'),
    format: 'umd',
    env: 'production',
    banner
  },
  // Runtime+compiler CommonJS build (CommonJS)
  'web-full-prod': {
    entry: resolve('web/entry-runtime-with-compiler.js'),
    dest: resolve('dist/vue.min.js'),
    format: 'umd',
    env: 'production',
    alias: { he: './entity-decoder' },
    banner
  },

  // ...
}

function genConfig (name) {
  const opts = builds[name]
  const config = {
    input: opts.entry,
    external: opts.external,
    plugins: [
      flow(),
      alias(Object.assign({}, aliases, opts.alias))
    ].concat(opts.plugins || []),
    output: {
      file: opts.dest,
      format: opts.format,
      banner: opts.banner,
      name: opts.moduleName || 'Vue'
    }
    // ...
  }
  // ...
  Object.defineProperty(config, '_name', {
    enumerable: false,
    value: name
  })
  return config

}

```

é€šè¿‡è¿™é‡Œçš„ä»£ç ç‰‡é¢å¤§æ¦‚äº†è§£åˆ° vue é€šè¿‡å½“å‰webã€æœåŠ¡ç«¯æ¸²æŸ“ã€webpackæ’ä»¶ã€weexç­‰é…ç½®æ¥è¿›è¡Œæ‰“åŒ…ï¼Œæ¯ä¸€ä¸ªé…ç½®éƒ½éµå¾ª rollup çš„æ„å»ºè§„åˆ™

```json
{
  "entry": "æ„å»ºçš„å…¥å£æ–‡ä»¶",
  "dest": "æ„å»ºåçš„æ–‡ä»¶åœ°å€",
  "format": "æ„å»ºè§„èŒƒ",
  "alias": "åˆ«åè®¾ç½®" 
  // ...
}

```

é‚£ä¹ˆåœ¨æ‰“åŒ…çš„è¿‡ç¨‹ä¸­è¿›è¡Œäº†è·¯å¾„åˆ«åè®¾ç½®ï¼Œé€šè¿‡åˆ«åè®¾ç½®èƒ½ä»£ç èƒ½å¤Ÿæ›´æ¸…æ™°æ•´æ´ã€‚

```js
const path = require('path')

const resolve = p => path.resolve(__dirname, '../', p)

module.exports = {
  vue: resolve('src/platforms/web/entry-runtime-with-compiler'),
  compiler: resolve('src/compiler'),
  core: resolve('src/core'),
  shared: resolve('src/shared'),
  web: resolve('src/platforms/web'),
  weex: resolve('src/platforms/weex'),
  server: resolve('src/server'),
  sfc: resolve('src/sfc')
}
```

çœ‹åˆ°è¿™ä¸ªåˆ«åè®¾ç½®ï¼Œæˆ‘ä»¬å°±åº”è¯¥å¾ˆæ¸…æ¥š vue çš„æ ¸å¿ƒæ„å»ºæ–‡ä»¶éƒ½åœ¨ src ç›®å½•ï¼Œå…·ä½“ä½œç”¨åœ¨æ–‡ç« å¼€å¤´å°±å·²ç»ä»‹ç»è¿‡äº†ã€‚é‚£ä¹ˆæˆ‘ä»¬ä¸»è¦çœ‹ web åˆ«åä¸‹çš„ç›®å½•ï¼Œå…¶å®ƒçš„ç›®å½•æœ‰å…´è¶£çš„åŒå­¦å¯ä»¥äº†è§£ä¸€ä¸‹å®ç°è§„åˆ™

```js
import Vue from 'core/index'
import config from 'core/config'
import { extend, noop } from 'shared/util'
import { mountComponent } from 'core/instance/lifecycle'
import { devtools, inBrowser } from 'core/util/index'

// ...

import { patch } from './patch'
import platformDirectives from './directives/index'
import platformComponents from './components/index'

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives)
extend(Vue.options.components, platformComponents)

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

// ...

```

ç»ˆäºçœ‹åˆ°äº† Vue æ„é€ å‡½æ•°å’Œæ ¸å¿ƒä»£ç çš„å…¥å£`core/index`ï¼Œå¹¶åœ¨æ„é€ å‡½æ•°å’ŒåŸå‹ä¸Šé¢æŒ‚è½½äº†ä¸€äº›æ–¹æ³•ï¼Œé€šè¿‡æ‰§è¡Œçš„ä¸Šè¿°æ„å»ºè¿‡ç¨‹æˆ‘ä»¬æ€»ç»“åˆ°

Vue.js çš„ç»„æˆæ˜¯ç”± core + å¯¹åº”çš„ â€˜å¹³å°â€™ è¡¥å……ä»£ç æ„æˆ(ç‹¬ç«‹æ„å»ºå’Œè¿è¡Œæ—¶æ„å»º åªæ˜¯ platforms ä¸‹ web å¹³å°çš„ä¸¤ç§é€‰æ‹©)

<img src="../assets/vue-init.png" width="50%"></img>


## new Vue


é€šè¿‡ vue çš„æ ¸å¿ƒç›®å½•ï¼Œæˆ‘ä»¬çŸ¥é“ Vue å®é™…ä¸Šæ˜¯ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œä¸Šé¢æŒ‚æ»¡äº†å¤§å¤§å°å°çš„å„ç§æ–¹æ³•æˆ‘ä»¬åœ¨ç”¨çš„æ—¶å€™ä¼ ä¸€å®šçš„å‚æ•°å³å¯

```js
new Vue({
  el: 'xxxx',
  data: xxxx,
  ...
})
```

### initGlobalAPI<hr/>

é‚£ä¹ˆåœ¨ vue å®ä¾‹åŒ–çš„è¿‡ç¨‹ä¸­åˆ°åº•å‘ç”Ÿäº†ä»€ä¹ˆï¼Œæ‰“å¼€æ ¸å¿ƒä»£ç  `src/core` ç›®å½•ä¸‹é¢çš„ index


```js
src/core/index.js

// vueåˆå§‹åŒ–çš„æ ¸å¿ƒæ–‡ä»¶--åˆ›å»ºVueæ„é€ å‡½æ•°ï¼Œå°†æ„é€ å‡½æ•°ä¼ å…¥äº”ä¸ªæ–¹æ³•ä¸­
import Vue from './instance/index'
// åˆå§‹åŒ–å…¨å±€API
import { initGlobalAPI } from './global-api/index'
// è·å¾—ä¸€äº›ç¯å¢ƒåˆ¤æ–­ï¼Œå’Œæ˜¯å¦æ˜¯æœåŠ¡ç«¯æ¸²æŸ“
import { isServerRendering } from 'core/util/env'
// ssr ç¯å¢ƒåŠ è½½æ­¤æ–¹æ³•
import { FunctionalRenderContext } from 'core/vdom/create-functional-component'

//åˆå§‹åŒ–å…¨å±€APIå˜é‡
initGlobalAPI(Vue)

//ä¸ºvueçš„åŸå‹å®šä¹‰$isServerå±æ€§
Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
})

//ä¸ºvueçš„åŸå‹å®šä¹‰$ssrContext
Object.defineProperty(Vue.prototype, '$ssrContext', {
  get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
})

//ä¸ºvueåŸå‹å®šä¹‰å½“ä¸ºssrç¯å¢ƒæ—¶åŠ è½½FunctionalRenderContextæ–¹æ³•
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
})

//æ·»åŠ ç‰ˆæœ¬å·
Vue.version = '__VERSION__'

export default Vue
```

æ€»ç»“ä¸€ä¸‹è¿™ä¸ªæ–‡ä»¶åŠ è½½çš„æ–¹æ³•

```md

core/index
â”œâ”€â”€ Vue            # åˆå§‹åŒ–æ„é€ å‡½æ•°
â”œâ”€â”€ initGlobalAPI  # åˆå§‹åŒ–å…¨å±€API
â”œâ”€â”€ $isServer      # åˆ¤æ–­ç¯å¢ƒçš„å·¥å…·å‡½æ•°
â”œâ”€â”€ $ssrContext    # ssr ç¯å¢ƒåŠ è½½æ­¤æ–¹æ³•ä¹Ÿå¯ç”¨äºæ“ä½œçŠ¶æ€
â”œâ”€â”€ FunctionalRenderContext  # ssr ç¯å¢ƒåŠ è½½æ­¤æ–¹æ³•
â”œâ”€â”€ æ·»åŠ ç‰ˆæœ¬å·
```
### new Vue <hr/>

åˆå§‹åŒ–æ–‡ä»¶åï¼Œè¿›å…¥å¯¼å‡º Vue æ„é€ å‡½æ•°çš„æ–‡ä»¶ `src/core/instance/index.js `

```js
function Vue (options) {
  if (process.env.NODE_ENV !== 'production' &&
    !(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword')
  }
  this._init(options)
}
```

ä¸Šé¢æˆ‘ä»¬çœ‹åˆ°äº† Vue å®é™…ä¸Šå°±æ˜¯ä¸€ä¸ªç”¨ Function å®ç°çš„ç±»ï¼Œé€šè¿‡ new å…³é”®å­—åˆå§‹åŒ–ï¼Œç„¶åä¼šè°ƒç”¨ this._init æ–¹æ³•ã€‚

```js
// ...
 Vue.prototype._init = function (options?: Object) {
    const vm: Component = this
    // a uid
    vm._uid = uid++

    let startTag, endTag
    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      startTag = `vue-perf-start:${vm._uid}`
      endTag = `vue-perf-end:${vm._uid}`
      mark(startTag)
    }

    // å¦‚æœæ˜¯Vueçš„å®ä¾‹ï¼Œåˆ™ä¸éœ€è¦è¢«observe
    vm._isVue = true

    // å¯¹å‚æ•°è¿›è¡Œ merge æ“ä½œ  
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options)
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      )
    }

    // é€šè¿‡åˆ¤æ–­ Proxy ä¸º vueçš„å®ä¾‹å±æ€§èµ‹å€¼
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      initProxy(vm)
    } else {
      vm._renderProxy = vm
    }

    vm._self = vm

    // åˆå§‹åŒ–ç”Ÿå‘½å‘¨æœŸç›¸å…³
    initLifecycle(vm)

    // è¾“åˆå§‹åŒ–äº‹ä»¶ç›‘å¬ç›¸å…³
    initEvents(vm)

    // åˆå§‹åŒ–ç¼–è¯‘render
    initRender(vm)

    // è°ƒç”¨beforeCreateé’©å­å‡½æ•°å¹¶ä¸”è§¦å‘beforeCreateé’©å­äº‹ä»¶
    callHook(vm, 'beforeCreate')

    initInjections(vm)

    // åˆå§‹åŒ–propsã€methodsã€dataã€computedä¸watch
    initState(vm)

    initProvide(vm)

    // è°ƒç”¨createdé’©å­å‡½æ•°å¹¶ä¸”è§¦å‘createdé’©å­äº‹ä»¶
    callHook(vm, 'created')


    /* istanbul ignore if */
    if (process.env.NODE_ENV !== 'production' && config.performance && mark) {
      // æ ¼å¼åŒ–ç»„ä»¶å
      vm._name = formatComponentName(vm, false)
      mark(endTag)
      measure(`vue ${vm._name} init`, startTag, endTag)
    }


    // æŒ‚è½½ç»„ä»¶æ–¹æ³•è§¦å‘ç»„ä»¶çš„DOMæ¸²æŸ“
    if (vm.$options.el) {
      vm.$mount(vm.$options.el)
    }
  }

// ...
```
é€šè¿‡ä¸Šé¢ä»£ç çš„æ³¨é‡Šäº†è§£åˆ° Vue åˆå§‹åŒ–ä¸»è¦å°±å¹²äº†å‡ ä»¶äº‹æƒ…ï¼Œåˆå¹¶é…ç½®æ“ä½œï¼Œåˆå§‹åŒ–ç”Ÿå‘½å‘¨æœŸï¼Œåˆå§‹åŒ–äº‹ä»¶ç›‘å¬ï¼Œåˆå§‹åŒ–renderï¼Œåˆå§‹åŒ– dataã€propsã€computedã€watcher ç­‰ï¼Œåœ¨æœ€åè°ƒç”¨vm.$mount æ–¹æ³•æŒ‚è½½ vm ï¼ŒæŠŠæ¨¡ç‰ˆæ¸²æŸ“æˆDOMã€‚å½“ç„¶è¿™é‡Œé¢è¿˜æœ‰å¾ˆå¤šç»†èŠ‚éœ€è¦çŸ¥é“ä¾‹å¦‚ä¸Šé¢åˆå§‹åŒ–åˆå¹¶é…ç½®ï¼Œç”Ÿå‘½å‘¨æœŸåˆå§‹åŒ–ç­‰ï¼Œä¼šåœ¨åé¢æ¸…æ¥šçš„æ¢³ç† vue æ•´ç†æµç¨‹ä¹‹åï¼Œè¿›å…¥ç»†èŠ‚

## vm.$mount

é€šè¿‡ $mount å®ä¾‹æ–¹æ³•å»æŒ‚è½½ vm ï¼Œä½† $mount æ–¹æ³•æ˜¯ç”±äºå¤šå¹³å°ç¼–è¯‘å¤„ç†ä¸å¤ªä¸€æ ·ï¼Œæ‰€ä»¥åœ¨å¤šä¸ªæ–‡ä»¶ä¸­å®šä¹‰ã€‚æˆ‘ä»¬è¿›å…¥ `src/platform` è¿™ä¸ªç›®å½•å¯ä»¥è§‚å¯Ÿåˆ°æœ‰ web å’Œ weex ç›®å½•ï¼Œæˆ‘ä»¬ç›´æ¥æŠ›æ‰ weexï¼Œåªåˆ†æ web ç›®å½•ï¼Œåœ¨ vue å®˜ç½‘æ•™ç¨‹ä¸­ä»‹ç»äº†vueçš„å®Œæ•´ç‰ˆ`web/entry-runtime-with-compiler.js`å’Œruntimeç‰ˆæœ¬`web/runtime/index.js`

å®Œæ•´ç‰ˆ

- åŒ…å«ç¼–è¯‘å’Œè¿è¡Œæ˜¯çš„ç‰ˆæœ¬
- htmlå­—ç¬¦ä¸² â†’ renderå‡½æ•° â†’ vnode â†’ çœŸå®domèŠ‚ç‚¹

runtimeç‰ˆæœ¬

- åˆ›å»º Vue å®ä¾‹ã€renderã€æ›´æ–° DOM ç­‰çš„æ“ä½œçš„ä»£ç ï¼Œæ²¡æœ‰ç¼–è¯‘å™¨ç¼–è¯‘æ¨¡ç‰ˆå­—ç¬¦ä¸²ä»£ç 
- renderå‡½æ•° â†’ vnode â†’ çœŸå®domèŠ‚ç‚¹


### å®Œæ•´ç‰ˆ $mount<hr>

```js
// ...

const mount = Vue.prototype.$mount
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && query(el)

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    process.env.NODE_ENV !== 'production' && warn(
      `Do not mount Vue to <html> or <body> - mount to normal elements instead.`
    )
    return this
  }

  const options = this.$options
  // resolve template/el and convert to render function
  if (!options.render) {
    let template = options.template
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template)
          /* istanbul ignore if */
          if (process.env.NODE_ENV !== 'production' && !template) {
            warn(
              `Template element not found or is empty: ${options.template}`,
              this
            )
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML
      } else {
        if (process.env.NODE_ENV !== 'production') {
          warn('invalid template option:' + template, this)
        }
        return this
      }
    } else if (el) {
      template = getOuterHTML(el)
    }
    if (template) {
      
      // ...
      const { render, staticRenderFns } = compileToFunctions(template, {
        outputSourceRange: process.env.NODE_ENV !== 'production',
        shouldDecodeNewlines,
        shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this)
      options.render = render
      options.staticRenderFns = staticRenderFns

      // ..
    }
  }
  return mount.call(this, el, hydrating)
}

// ...
```

ä¸Šé¢ä»£ç é€»è¾‘å¾ˆæ¸…æ™°ï¼Œå°†æ‰§è¡Œä»¥ä¸‹è¿‡ç¨‹

- é¦–å…ˆåœ¨åŸå‹ä¸Šå®šä¹‰äº† $mount è¿™ä¸ªæ–¹æ³•
- å¯¹ä¼ å…¥çš„ el åšé™åˆ¶ä¸èƒ½å°†èŠ‚ç‚¹æŒ‚è½½åœ¨ body å’Œ html è¿™ç§è·ŸèŠ‚ç‚¹ä¸Š
- å¦‚æœæ²¡æœ‰å®šä¹‰ render æ–¹æ³•ï¼Œåˆ™ä¼šæŠŠ el æˆ–è€… template å­—ç¬¦ä¸²è½¬æ¢æˆ render æ–¹æ³•
- æ¨¡ç‰ˆæˆ–å­—ç¬¦ä¸²è½¬æ¢ render æ–¹æ³•ï¼ˆè°ƒç”¨ compileToFunctions è¿›è¡Œç¼–è¯‘è½¬æ¢ï¼‰


### runtime ç‰ˆæœ¬ $mount<hr>

```js
// ...

// public mount method
Vue.prototype.$mount = function (
  el?: string | Element,
  hydrating?: boolean
): Component {
  el = el && inBrowser ? query(el) : undefined
  return mountComponent(this, el, hydrating)
}

// ...

```

æ‰§è¡Œè¿‡ç¨‹
- æŒ‚è½½çš„å…ƒç´ ï¼Œå¯ä»¥æ˜¯å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥æ˜¯DOMå¯¹è±¡ï¼Œå¦‚æœæ˜¯å­—ç¬¦ä¸²é€šè¿‡ query æ–¹æ³•è½¬æ¢æˆDOM
- æ‰§è¡Œ mountComponent å‡½æ•°ä¼ å…¥ä¸‰ä¸ªå‚æ•°
 
é€šè¿‡ä¸Šé¢ä»£ç å¯ä»¥çœ‹å‡ºå¹¶æ²¡æœ‰ç»è¿‡ compileToFunctionsæ–¹æ³• è¿›è¡Œè½¬æ¢ç¼–è¯‘é˜¶æ®µï¼Œè€Œç›´æ¥æ˜¯ render --> VNode è¿‡ç¨‹ã€‚

æ¥ä¸‹æ¥æˆ‘ä»¬æ¥ç€æŸ¥çœ‹ mountComponentæ–¹æ³•è°ƒç”¨ï¼Œæ‰“å¼€æ–‡ä»¶`src/core/instance/lifecycle.js`

```js
export function mountComponent (
  vm: Component,
  el: ?Element,
  hydrating?: boolean
): Component {
  vm.$el = el
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode
    // ...
  }
  callHook(vm, 'beforeMount')

  let updateComponent
  
  // ...

  updateComponent = () => {
    vm._update(vm._render(), hydrating)
  }

  // ...

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate')
      }
    }
  }, true /* isRenderWatcher */)
  hydrating = false

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true
    callHook(vm, 'mounted')
  }
  return vm
}
```

é€šè¿‡ä¸Šé¢ä»£ç å¾ˆç›´è§‚çš„çœ‹è§ mountComponent æ–¹æ³•ä¸»è¦ä½œç”¨

- åˆ¤æ–­ render å‡½æ•°æ˜¯ä¸æ˜¯å­˜åœ¨å¦‚æœä¸å­˜åœ¨è°ƒç”¨åˆ›å»º createEmptyVNode æ–¹æ³•åˆ›å»ºä¸€ä¸ªç©ºVNodeèŠ‚ç‚¹
- æ£€æµ‹å®Œ render å¼€å§‹æŒ‚è½½ beforeMount é’©å­
- æ‰§è¡Œ new Watcheræ–¹æ³•()
- _isMountedçŠ¶æ€è®¾ç½®trueï¼Œ å¼€å§‹æŒ‚è½½mounted


Watcher åœ¨å®ƒçš„å›è°ƒå‡½æ•°ä¸­ä¼šè°ƒç”¨ updateComponent æ–¹æ³•ï¼Œåœ¨æ­¤æ–¹æ³•ä¸­è°ƒç”¨ vm._render æ–¹æ³•ç”Ÿæˆè™šæ‹Ÿ NodeèŠ‚ç‚¹ï¼Œæœ€åè°ƒç”¨ vm._update æ›´æ–° DOM

Watcher åˆå§‹åŒ–çš„æ—¶å€™ä¼šæ‰§è¡Œå›è°ƒå‡½æ•°ï¼Œå½“ vm å®ä¾‹ä¸­çš„ç›‘æµ‹çš„æ•°æ®å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ä¹Ÿä¼šæ‰§è¡Œå›è°ƒå‡½æ•°ï¼Œè¿™å°±æ˜¯æˆ‘ä»¬è¯´çš„è§‚å¯Ÿè€…è¿›è¡Œä¾èµ–æ”¶é›†çš„è¿‡ç¨‹,å½“ç„¶è¿™ä¹Ÿæ˜¯ vue æ ¸å¿ƒåŸç†çš„ä¸€éƒ¨åˆ†ã€‚new Watcheråˆ°åº•åšäº†ä»€ä¹ˆæˆ‘ä»¬åœ¨åé¢çš„å•ç‹¬æ•´ç†ï¼Œå…ˆä»¥ä¸»çº¿ç¨‹ä¸ºä¸»


## vm._render

ä¸Šæ–‡ä¸­æåˆ° Watcher åœ¨å®ƒçš„å›è°ƒå‡½æ•°ä¸­ä¼šè°ƒç”¨ updateComponent æ–¹æ³•ï¼Œåœ¨æ­¤æ–¹æ³•ä¸­è°ƒç”¨ vm._render æ–¹æ³•ç”Ÿæˆè™šæ‹Ÿ NodeèŠ‚ç‚¹ï¼Œæœ€åè°ƒç”¨ vm._update æ›´æ–° DOMï¼Œé‚£ä¹ˆå°±å‡ºç° ç§æœ‰æ–¹æ³• vm._render å’Œ vm._update ä¸¤ä¸ªæœ€æ ¸å¿ƒçš„æ–¹æ³•ã€‚
 
_render å®šä¹‰åœ¨ `src/core/instance/render.js` ä¸­

```js

  // ...
  Vue.prototype._render = function (): VNode {
    const vm: Component = this
    const { render, _parentVnode } = vm.$options

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      )
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode
    // render self
    let vnode
    try {
      // There's no need to maintain a stack because all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm
      vnode = render.call(vm._renderProxy, vm.$createElement)
    } catch (e) {
      handleError(e, vm, `render`)
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production' && vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)
        } catch (e) {
          handleError(e, vm, `renderError`)
          vnode = vm._vnode
        }
      } else {
        vnode = vm._vnode
      }
    } finally {
      currentRenderingInstance = null
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0]
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (process.env.NODE_ENV !== 'production' && Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        )
      }
      vnode = createEmptyVNode()
    }
    // set parent
    vnode.parent = _parentVnode
    return vnode
  }
```


ä¸Šé¢è¿™æ®µä»£ç æœ€å…³é”®çš„åœ°æ–¹å°±æ˜¯è°ƒç”¨ render æ–¹æ³• `render.call(vm._renderProxy, vm.$createElement)`ï¼Œåœ¨ä¸Šé¢è¯´è¿‡åœ¨ mounted æ–¹æ³•ä¸­ä¼šæŠŠ template å’Œ string ç»è¿‡ compileToFunctions ç¼–è¯‘æœ€åå½¢æˆ renderæ–¹æ³•è¿›è¡Œæ¸²æŸ“ï¼Œä½†æ˜¯è¿™æ˜¯ç”¨å­—ç¬¦ä¸²æ¨¡ç‰ˆçš„å½¢å¼ï¼Œå¦‚æœç”¨å­—ç¬¦ä¸²æ¨¡æ¿çš„ä»£æ›¿æ–¹æ¡ˆ render æ–¹æ³•å‘¢


```js
new Vue({
  render: function (createElement) {
   return createElement('div', {
     attrs: {
        id: 'app'
      },
  }, this.message)
  },
  renderError: function(createElement, err) {
    return createElement('pre', { style: { color: 'red' }}, err.stack)
  }
}).$mount('#app')
```

æˆ‘ä»¬å¯ä»¥çœ‹å‡ºrender æ–¹æ³•çš„å‚æ•° createElement å®é™…ä¸Šå°±æ˜¯ vm.$createElement,ç„¶è€Œ vm.$createElement åœ¨åˆå§‹åŒ–ä¸­å°±å·²ç»æ‰§è¡Œè¿‡äº†

```js
export function initRender (vm: Component) {
  
  // ...

  vm._c = (a, b, c, d) => createElement(vm, a, b, c, d, false)
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = (a, b, c, d) => createElement(vm, a, b, c, d, true)

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  const parentData = parentVnode && parentVnode.data

  // ...

}
```

æ‰€ä»¥åœ¨ initRender æ–¹æ³•çš„æ—¶å€™ï¼Œé™¤äº† vm.$createElement æ–¹æ³•ï¼Œè¿˜æœ‰ä¸€ä¸ª vm._c æ–¹æ³•ï¼Œå®ƒæ˜¯è¢«æ¨¡æ¿ç¼–è¯‘æˆçš„ render å‡½æ•°ä½¿ç”¨ï¼Œä½† vm.$createElement æ˜¯æˆ‘ä»¬ç”¨åŸç”Ÿå†™çš„ render æ–¹æ³•ä½¿ç”¨çš„ï¼Œ è¿™ä¿©ä¸ªæ–¹æ³•æ”¯æŒçš„å‚æ•°ç›¸åŒï¼Œå¹¶ä¸”å†…éƒ¨éƒ½è°ƒç”¨äº† createElement æ–¹æ³•ã€‚

å®˜ç½‘ä¸­ä¸€å¥è¯è¯´çš„å¾ˆæ¸…æ¥š **Vue é€‰é¡¹ä¸­çš„ render å‡½æ•°è‹¥å­˜åœ¨ï¼Œåˆ™ Vue æ„é€ å‡½æ•°ä¸ä¼šä» template é€‰é¡¹æˆ–é€šè¿‡ el é€‰é¡¹æŒ‡å®šçš„æŒ‚è½½å…ƒç´ ä¸­æå–å‡ºçš„ HTML æ¨¡æ¿ç¼–è¯‘æ¸²æŸ“å‡½æ•°ã€‚**

é€šè¿‡ä¸Šè¿°æ€»ç»“åˆ° render å‡½æ•°æœ€ç»ˆæ˜¯æ‰§è¡Œ createElement æ–¹æ³• è¿”å› vnode èŠ‚ç‚¹ï¼Œè¿™æ˜¯ä¸€ä¸ªè™šæ‹Ÿ node è€Œ vue2.0 çš„ å¦ä¸€ä¸ªæ ¸å¿ƒå°±æ˜¯åˆ©ç”¨äº†Virtual DOMï¼Œå®é™…ä¸Š Vue.js ä¸­ Virtual DOM æ˜¯å€Ÿé‰´äº†å¼€æºåº“ <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> çš„å®ç°ï¼Œç„¶ååŠ å…¥äº†ä¸€äº› Vue.js ç‰¹è‰²çš„ä¸œè¥¿, è¿™éƒ¨åˆ†æºç å°±åœ¨ `src/core/vdom/vnode.js` ä¸­æˆ‘ä»¬æš‚æ—¶ä¸å»æŸ¥çœ‹ï¼Œå¾…åç»­æ–‡ç« å†™åˆ° Virtual DOM çš„æ—¶å€™æˆ‘ä»¬åœ¨åšåˆ†æã€‚ 

é‚£ä¹ˆåœ¨é¢è¯•ä¸­æˆ‘ä»¬ç»å¸¸è¢«é—®åˆ°æ˜¯ æ“ä½œ Virtual DOM å¿«è¿˜æ˜¯çœŸå® DOM å¿«

ç­”æ¡ˆæ˜¯ç›¸å¯¹çš„åœ¨æ•°æ®é‡å¤§çš„æƒ…å†µä¸‹ï¼Œè‚¯å®šæ˜¯ Virtual DOM å¿«ï¼Œå› ä¸ºé€šè¿‡å¯¹æ¯” node å‡å°‘é¢‘ç¹çš„å»æ›´æ–°DOMï¼Œ å¦‚æœæ•°æ®é‡ç›¸å¯¹è¾ƒå°çš„æƒ…å†µè¿˜æ˜¯ç›´æ¥æ“ä½œ DOM è¾ƒå¿«ï¼Œå› ä¸ºå°‘äº†ç¼–è¯‘ã€éå†ã€å¯¹æ¯”çš„è¿‡ç¨‹

## vm.$createElement

ä¸Šé¢æ–‡ç« æåˆ° render çš„æ—¶å€™å†…éƒ¨è°ƒç”¨äº† createElement æ–¹æ³•ï¼Œåˆ›å»ºäº†vnodeï¼Œè¯¥æ–¹æ³•å®šä¹‰åœ¨ src/core/vdom/create-elemenet.js ä¸­

```js
// ...

export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {

   /**
   * å¦‚æœå­˜åœ¨data.__ob__ï¼Œè¯´æ˜dataæ˜¯è¢«Observerè§‚å¯Ÿçš„æ•°æ®
   * ä¸èƒ½ç”¨ä½œè™šæ‹ŸèŠ‚ç‚¹çš„data
   * éœ€è¦æŠ›å‡ºè­¦å‘Šï¼Œå¹¶è¿”å›ä¸€ä¸ªç©ºèŠ‚ç‚¹
   *
   * è¢«ç›‘æ§çš„dataä¸èƒ½è¢«ç”¨ä½œvnodeæ¸²æŸ“çš„æ•°æ®çš„åŸå› æ˜¯ï¼š
   * dataåœ¨vnodeæ¸²æŸ“è¿‡ç¨‹ä¸­å¯èƒ½ä¼šè¢«æ”¹å˜ï¼Œè¿™æ ·ä¼šè§¦å‘ç›‘æ§ï¼Œå¯¼è‡´ä¸ç¬¦åˆé¢„æœŸçš„æ“ä½œ
   */   
  if (isDef(data) && isDef((data: any).__ob__)) {
    process.env.NODE_ENV !== 'production' && warn(
      `Avoid using observed data object as vnode data: ${JSON.stringify(data)}\n` +
      'Always create fresh vnode data objects in each render!',
      context
    )
    return createEmptyVNode()
  }

  // å½“é€šè¿‡ :is åŠ¨æ€è®¾ç½®ç»„ä»¶æ—¶
  if (isDef(data) && isDef(data.is)) {
    tag = data.is
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }


  // ...

  // ä½œç”¨åŸŸæ’æ§½
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {}
    data.scopedSlots = { default: children[0] }
    children.length = 0
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children)
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children)
  }
  let vnode, ns
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      if (process.env.NODE_ENV !== 'production' && isDef(data) && isDef(data.nativeOn)) {
        warn(
          `The .native modifier for v-on is only valid on components but it was used on <${tag}>.`,
          context
        )
      }
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      )
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      )
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}

// ...

```

é€šè¿‡ä¸Šé¢ä»£ç æˆ‘ä»¬çœ‹åˆ° ä¸»è¦è°ƒç”¨äº†å‡ ä¸ªæ–¹æ³• createEmptyVNode å’Œ createComponentã€normalizeChildrenã€simpleNormalizeChildren

æˆ‘ä»¬ç®€å•çš„çœ‹ä¸€ä¸‹æ‰§è¡Œæ­¥éª¤

é¦–å…ˆåˆ¤æ–­äº† tag æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è°ƒç”¨ `src/core/vdom/vnode.js`ç›®å½•ä¸‹çš„ createEmptyVNode æ–¹æ³•åˆ›å»ºç©ºçš„ vnode èŠ‚ç‚¹

å¦‚æœä¼ é€’äº†childrenï¼Œç”±äºå…¶æ˜¯ä»»æ„ç±»å‹ï¼Œæ‰€ä»¥æ ¹æ® normalizationType å»è°ƒç”¨`src/core/vdom/helpers/normalzie-children.js` ç›®å½•ä¸‹çš„ normalizeChildren(children) å’Œ simpleNormalizeChildren(children) æ–¹æ³•è¿›è¡Œé€’å½’éå†ï¼ŒæŠŠæ•´ä¸ª children æ‰“å¹³ï¼Œè®©å®ƒå˜æˆæ·±åº¦åªæœ‰ä¸€å±‚çš„ vnode æ•°ç»„

æœ€åé€šè¿‡ å¯¹å‚æ•° tag çš„åˆ¤æ–­ï¼Œå¦‚æœæ˜¯ä¸€ä¸ªæ™®é€šçš„ html æ ‡ç­¾ï¼Œåˆ™å®ä¾‹åŒ–ä¸€ä¸ªæ™®é€š vnode èŠ‚ç‚¹ï¼Œå¦åˆ™é€šè¿‡ `src/core/vdom/create-component.js`ç›®å½•ä¸‹çš„ createComponent æ–¹æ³•åˆ›å»ºä¸€ä¸ªç»„ä»¶çš„ vnode

å› ä¸ºé™¤äº†ç»„ä»¶çš„ vnode æ²¡æœ‰ childrenï¼Œå…¶ä»–é€šè¿‡ createElement åˆ›å»ºçš„æ¯ä¸ª vnode éƒ½æœ‰ childrenï¼Œchildren æ¯ä¸ªå…ƒç´ ä¹Ÿæ˜¯ä¸€ä¸ª vnodeï¼Œè¿™æ ·å°±å½¢æˆäº†ä¸€ä¸ª vnode treeï¼Œè¿™æ ·æˆ‘ä»¬å°±çŸ¥é“ vm._render é˜¶æ®µæ˜¯å¦‚ä½•åˆ›å»ºçš„ vnodeï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬å°±é€šè¿‡ vm._updateï¼Œå°† vnode æ¸²æŸ“æˆçœŸå®çš„ domã€‚

## vm._update

vm._update ä¹Ÿæ˜¯ä¸€ä¸ªç§æœ‰æ–¹æ³•ï¼Œä½œç”¨æ˜¯æŠŠ vnode æ¸²æŸ“æˆçœŸå®çš„ dom åœ¨ `src/core/instance/lifecycle.js` æ–‡ä»¶ä¸­å®šä¹‰

### _update <hr/>

```js

  // ...


  Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
    const vm: Component = this
    const prevEl = vm.$el
    const prevVnode = vm._vnode
    const restoreActiveInstance = setActiveInstance(vm)
    vm._vnode = vnode
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode)
    }
    restoreActiveInstance()
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  }

  // ...
```

é€šè¿‡ä¸Šé¢ä»£ç æˆ‘ä»¬çŸ¥é“ vm._update çš„æ ¸å¿ƒå°±æ˜¯é€šè¿‡ vm.__patch__å‡½æ•°æ¥å®ç°å°† vnode è½¬æ¢æˆçœŸå®çš„ node èŠ‚ç‚¹ï¼Œè€Œ vm.__patch__ çš„å®ç°æ˜¯å¤šå¹³å°çš„æœ‰weexã€ssrã€inBrowserï¼Œæˆ‘ä»¬åªæŸ¥çœ‹åœ¨æµè§ˆå™¨ç¯å¢ƒå†…çš„å®ç°

åœ¨ `src/platforms/web/runtime/index.js` é€šè¿‡åˆ¤æ–­å¦‚æœæ˜¯æµè§ˆå™¨ç¯å¢ƒè°ƒç”¨ patchï¼Œå¦åˆ™åˆ›å»ºä¸€ä¸ªç©ºå¯¹è±¡

### __patch__ <hr/>

```js
// ...

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop

// ...
```

é€šè¿‡å¼•ç”¨æˆ‘ä»¬åˆ° `src/platforms/web/runtime/patch.js` ç›®å½•çœ‹åˆ°è°ƒç”¨äº† createPatchFunction æ–¹æ³•çš„è¿”å›å€¼

```js
export const patch: Function = createPatchFunction({ nodeOps, modules })
```

### createPatchFunction <hr>

åœ¨é€šè¿‡æŸ¥æ‰¾æ–‡ä»¶ `src/core/vdom/patch.js` ä¸­å®šä¹‰çš„ createPatchFunction æ–¹æ³•

```js

// ...

export function createPatchFunction (backend) {

  // ...
  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    // å¦‚æœ vnode ä¸å­˜åœ¨ä½† oldVnode å­˜åœ¨ï¼Œè°ƒç”¨ invokeDestroyHook(oldVnode) æ¥è¿›è¡Œé”€æ¯æ—§èŠ‚ç‚¹
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
      return
    }

    let isInitialPatch = false
    const insertedVnodeQueue = []

    // å¦‚æœoldVnodeä¸å­˜åœ¨ï¼Œvnodeå­˜åœ¨ï¼Œåˆ™åˆ›å»ºæ–°èŠ‚ç‚¹  
    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true
      createElm(vnode, insertedVnodeQueue)
    } else {

      const isRealElement = isDef(oldVnode.nodeType)
      // å¦‚æœ oldVnode ä¸ vnode éƒ½å­˜åœ¨åˆ¤æ–­æ˜¯åŒä¸€èŠ‚ç‚¹è°ƒç”¨ patchVnode å¤„ç†å»æ¯”è¾ƒä¸¤ä¸ªèŠ‚ç‚¹çš„å·®å¼‚
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
      } else {

        if (isRealElement) {

          // å¦‚æœå­˜åœ¨çœŸå®çš„èŠ‚ç‚¹ï¼Œå­˜åœ¨data-server-renderedå±æ€§ï¼Œå°† hydrating å˜ä¸ºtrue
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR)
            hydrating = true
          }

          // ç”¨hydrateå‡½æ•°å°†è™šæ‹ŸDOMå’ŒçœŸå®DOMè¿›è¡Œæ˜ å°„
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true)
              return oldVnode
            }
            // ...
          }

          // å¦‚æœä¸æ˜¯server-rendered æˆ–è€…hydrationå¤±è´¥
          // åˆ›å»ºä¸€ä¸ªç©ºVNodeï¼Œä»£æ›¿oldVnode
          oldVnode = emptyNodeAt(oldVnode)
        }

        // å°†oldVnodeè®¾ç½®ä¸ºå¯¹åº”çš„è™šæ‹Ÿdomï¼Œæ‰¾åˆ°oldVnode.elmçš„çˆ¶èŠ‚ç‚¹
        // æ ¹æ®vnodeåˆ›å»ºä¸€ä¸ªçœŸå®domèŠ‚ç‚¹å¹¶æ’å…¥åˆ°è¯¥çˆ¶èŠ‚ç‚¹ä¸­oldVnode.elmçš„ä½ç½®
        const oldElm = oldVnode.elm
        const parentElm = nodeOps.parentNode(oldElm)
        createElm(
          vnode,
          insertedVnodeQueue,
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        )

        // é€’å½’æ›´æ–°çˆ¶çº§å ä½èŠ‚ç‚¹å…ƒç´ ï¼Œ
        if (isDef(vnode.parent)) {
          let ancestor = vnode.parent
          const patchable = isPatchable(vnode)
          while (ancestor) {
            for (let i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor)
            }
            ancestor.elm = vnode.elm
            if (patchable) {
              for (let i = 0; i < cbs.create.length; ++i) {
                cbs.create[i](emptyNode, ancestor)
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              const insert = ancestor.data.hook.insert
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (let i = 1; i < insert.fns.length; i++) {
                  insert.fns[i]()
                }
              }
            } else {
              registerRef(ancestor)
            }
            ancestor = ancestor.parent
          }
        }

        // é”€æ¯æ—§èŠ‚ç‚¹
        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0)
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode)
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)

    // è¿”å›èŠ‚ç‚¹
    return vnode.elm
  }
}

```

é€šè¿‡ä¸Šé¢çœ‹åˆ° patch æ–¹æ³•æœ¬èº«

æ¥æ”¶ 4ä¸ªå‚æ•°

- oldVnode è¡¨ç¤ºæ—§çš„ VNode èŠ‚ç‚¹æˆ–è€…æˆ–è€…æ˜¯ä¸€ä¸ª DOM å¯¹è±¡
- vnode è¡¨ç¤ºæ‰§è¡Œ _render åè¿”å›çš„ VNode çš„èŠ‚ç‚¹
- hydrating è¡¨ç¤ºæ˜¯å¦æ˜¯æœåŠ¡ç«¯æ¸²æŸ“
- removeOnly æ˜¯ç»™ transition-group ç”¨çš„ï¼Œé˜²æ­¢åœ¨ updateChildren é˜¶æ®µï¼Œç§»åŠ¨ vnode èŠ‚ç‚¹

å…³é”®è°ƒç”¨ä¸‰ä¸ªæ–¹æ³•

- createElm ä»¥å½“å‰æ—§èŠ‚ç‚¹ä¸ºå‚è€ƒèŠ‚ç‚¹ï¼Œåˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œæ‰§è¡Œç›¸å…³çš„ insert é’©å­å‡½æ•°ï¼Œå¹¶æ’å…¥åˆ° DOM ä¸­ï¼Œ
- sameVnode é€šè¿‡å¯¹æ¯” key æ˜¯å¦ç›¸åŒã€tagã€æ³¨é‡Šã€dataæ˜¯å¦å­˜åœ¨ç­‰åˆ¤æ–­2ä¸ªèŠ‚ç‚¹ï¼Œæ˜¯å¦æ˜¯åŒä¸€ä¸ªèŠ‚ç‚¹
- patchVnode vdom æ ¸å¿ƒæ›´æ–° node 

patchVode ä¸­çš„å‡ ä¸ªæ ¸å¿ƒæ–¹æ³• addVnodesã€ removeVnodesï¼ŒupdateChildrenï¼Œå…·ä½“æ˜¯æ€ä¹ˆå¢åŠ ã€åˆ é™¤ï¼Œæ›´æ–° vnode å’Œ dom èŠ‚ç‚¹çš„ï¼Œdom-diff æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬ä¼šåœ¨åˆ†æå“åº”å¼åŸç†çš„æ—¶å€™å…·ä½“æŸ¥çœ‹ç»†èŠ‚


### ä¸»æµç¨‹æ€»ç»“<hr>

ä¸‹é¢æˆ‘ä»¬é€šè¿‡ä¸€å¼ å›¾æ¥æ€»ç»“ vue ä¸»çº¿æµç¨‹

<img src="../assets/vue-process.png" /></img>

ä¸Šé¢çš„å›¾ä¸­èƒ½å¤Ÿç›´è§‚çš„çœ‹åˆ° vue ä¸»å¹²çš„æ‰§è¡Œæµç¨‹ï¼Œä½†æ˜¯ç¼ºå°‘æ ¸å¿ƒéƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯ vue çš„å“åº”å¼åŸç†ï¼Œä¸‹ç¯‡æ–‡ç« æˆ‘ä»¬ä¹Ÿæ˜¯é€šè¿‡æ–‡ä»¶çš„æ‰§è¡Œè¿‡ç¨‹æ¥åˆ†æ vue å“åº”å¼åŸç†çš„å®ç°

























































                

