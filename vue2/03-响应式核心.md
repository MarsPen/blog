
<h1 align="center">ğŸ“–å“åº”å¼åŸç†åˆ†æ</h1>
## å“åº”å¼å¯¹è±¡

æåˆ° vue çš„åŒå‘æ•°æ®ç»‘å®šåŸç†ï¼Œæˆ‘ä»¬éƒ½çŸ¥é“æ˜¯åˆ©ç”¨äº† `Object.defineProperty` ç»™æ•°æ®æ·»åŠ  getter å’Œ setterï¼Œæ¥è¿›è¡Œä¾èµ–æ”¶é›†å’Œæ•°æ®æ´¾å‘æ›´æ–°ï¼Œé¦–å…ˆæˆ‘ä»¬å†æ¥ç†Ÿæ‚‰ä¸€ä¸‹è¿™ä¸ªæ–¹æ³•

### Object.defineProperty <hr>

MDN ä¸­å†™åˆ° `Object.defineProperty()` æ–¹æ³•ä¼šç›´æ¥åœ¨ä¸€ä¸ªå¯¹è±¡ä¸Šå®šä¹‰ä¸€ä¸ªæ–°å±æ€§ï¼Œæˆ–è€…ä¿®æ”¹ä¸€ä¸ªå¯¹è±¡çš„ç°æœ‰å±æ€§ï¼Œ å¹¶è¿”å›è¿™ä¸ªå¯¹è±¡

```js

function Person () {}

Object.defineProperty(Person.prototype, 'sayHello', {
  enumerable: true,
  configurable: true,
  get: function () {
    return `my name is ${this.name}`
  },
  set:function (value) {
    this.name = value
  }
})
let p = new Person()
p.name = 'renbo'
console.log(p.sayHello) // my name is renbo
```
æˆ‘ä»¬åœ¨å®ç°ä¸€ä¸ªæç®€ç‰ˆåŒå‘ç»‘å®š

```html

<div>è¯·è¾“å…¥:</div>
<input type="text" id="input">
<div id="content"></div>

```

```js
  
let obj = {}

Object.definePerperty(obj,'text', {

  get:function () {
    console.log('è·å¾—çš„å€¼')
  },
  set:function (newVal) {
    console.log('è®¾ç½®çš„å€¼')
    document.getElementById('input').value = newVal
    document.getElementById('content').innerHTML = newVal;
  }
})

const input = document.getElementById('input');
input.addEventListener('keyup', function(e){
  obj.text = e.target.value;
})

```

set æä¾› setter æ–¹æ³•ï¼Œå½“æˆ‘ä»¬å¯¹ p.name åšä¿®æ”¹çš„æ—¶å€™ä¼šè§¦å‘ setter æ–¹æ³•ï¼Œ æˆ‘ä»¬è®¿é—® sayHello çš„æ—¶å€™ä¼šè§¦å‘ getter æ–¹æ³•ï¼Œå–åˆ°å¯¹åº”çš„å€¼ï¼Œé‚£ä¹ˆä¸€æ—¦å¯¹è±¡æ‹¥æœ‰äº† getter å’Œ setterï¼Œå°±æŠŠè¿™ä¸ªå¯¹è±¡å˜ä¸ºè‡ªåŠ¨å­˜å–çš„å“åº”å¯¹è±¡

### initState <hr>

åœ¨ vue _init é˜¶æ®µæˆ‘ä»¬è¿˜æ‰§è¡Œäº† initState(vm) æ–¹æ³•ï¼Œæˆ‘ä»¬ä¸Šç¯‡æ–‡ç« å†™åˆ°è¿™ä¸ªæ–¹æ³•ä¸»è¦æ˜¯å¯¹ propsã€methodsã€dataã€computed å’Œ wathcer ç­‰å±æ€§åšäº†åˆå§‹åŒ–æ“ä½œ,åœ¨ `src/core/instance/state.js ä¸­å®šä¹‰`

```js
export function initState (vm: Component) {
  vm._watchers = []
  const opts = vm.$options
  if (opts.props) initProps(vm, opts.props)
  if (opts.methods) initMethods(vm, opts.methods)
  if (opts.data) {
    initData(vm)
  } else {
    observe(vm._data = {}, true /* asRootData */)
  }
  if (opts.computed) initComputed(vm, opts.computed)
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch)
  }
}

```

### initProps <hr>

```js
function initProps (vm: Component, propsOptions: Object) {
  const propsData = vm.$options.propsData || {}
  const props = vm._props = {}
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  const keys = vm.$options._propKeys = []
  const isRoot = !vm.$parent
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false)
  }
  for (const key in propsOptions) {
    keys.push(key)
    const value = validateProp(key, propsOptions, propsData, vm)
    /* istanbul ignore else */
    if (process.env.NODE_ENV !== 'production') {
      const hyphenatedKey = hyphenate(key)
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          `"${hyphenatedKey}" is a reserved attribute and cannot be used as component prop.`,
          vm
        )
      }
      defineReactive(props, key, value, () => {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            `Avoid mutating a prop directly since the value will be ` +
            `overwritten whenever the parent component re-renders. ` +
            `Instead, use a data or computed property based on the prop's ` +
            `value. Prop being mutated: "${key}"`,
            vm
          )
        }
      })
    } else {
      defineReactive(props, key, value)
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, `_props`, key)
    }
  }
  toggleObserving(true)
}
```

ä»ä¸Šé¢ä»£ç ä¸­æˆ‘ä»¬çœ‹åˆ° props è¿‡ç¨‹ï¼Œä¸»è¦å°±æ˜¯éå† propsOptions ï¼Œè°ƒç”¨ defineReactive æ–¹æ³•å’Œ proxyï¼Œä½†æ˜¯ä¸Šé¢åœ¨å¼€å‘ç¯å¢ƒä¸­è°ƒç”¨ defineReactive ç»™ä¸€ä¸ªè­¦å‘Šï¼Œå¹³æ—¶æˆ‘ä»¬é€šè¿‡ props æ–¹æ³•æ¥æ¥å—çˆ¶ç»„ä»¶æ‰€ä¼ è¿‡æ¥çš„å€¼ï¼Œä½†æ˜¯è¿™ä¸ªè¿‡ç¨‹æ˜¯å•é¡¹çš„ï¼Œçˆ¶ç»„ä»¶å¯ä»¥æ”¹å˜ä¼ ç»™å­ç»„ä»¶çš„å€¼ï¼Œä½†æ˜¯å¦‚æœå­ç»„ä»¶æƒ³æ”¹å˜æ‰€æ¥å—çš„å€¼å¹¶ä¼ ç»™çˆ¶ç»„ä»¶æ˜¯ä¸å¯ä»¥çš„ï¼Œä¼šæ”¶åˆ°è¿™ä¸ªè­¦å‘Š

è¿™ä¸ªé”™è¯¯å‘Šè¯‰æˆ‘ä»¬é¿å…å»ç›´æ¥æ›´æ”¹ props å› ä¸ºå½“çˆ¶ç»„ä»¶é‡æ–°æ¸²æŸ“æ—¶ï¼Œè¯¥å€¼å°±ä¼šè¢«è¦†ç›–ã€‚è¿™ä¸ªæ—¶å€™å°±éœ€è¦ç”¨åˆ°è®¡ç®—å±æ€§æˆ–è€…ä¾¦å¬å±æ€§äº†ã€‚

defineReactive æ–¹æ³•å’Œ proxy å…·ä½“ä½œç”¨æˆ‘ä»¬åœ¨åé¢ä»‹ç»ã€‚

### initData<hr>

```js
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
  if (!isPlainObject(data)) {
    data = {}
    process.env.NODE_ENV !== 'production' && warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    )
  }
  // proxy data on instance
  const keys = Object.keys(data)
  const props = vm.$options.props
  const methods = vm.$options.methods
  let i = keys.length
  while (i--) {
    const key = keys[i]
    if (process.env.NODE_ENV !== 'production') {
      if (methods && hasOwn(methods, key)) {
        warn(
          `Method "${key}" has already been defined as a data property.`,
          vm
        )
      }
    }
    if (props && hasOwn(props, key)) {
      process.env.NODE_ENV !== 'production' && warn(
        `The data property "${key}" is already declared as a prop. ` +
        `Use prop default value instead.`,
        vm
      )
    } else if (!isReserved(key)) {
      proxy(vm, `_data`, key)
    }
  }
  // observe data
  observe(data, true /* asRootData */)
}
```

initData ä¸»è¦æ˜¯éå†dataï¼Œå–åˆ°å¯¹åº”çš„key è°ƒç”¨ proxy ï¼›å¦ä¸€ä¸ªæ˜¯è°ƒç”¨ observe æ–¹æ³•

### proxy<hr>

å¹³æ—¶æˆ‘ä»¬å†™ vue çš„æ—¶å€™æˆ‘ä»¬å¯ä»¥ç›´æ¥åœ¨æ–¹æ³•ä¸­è®¿é—® props å’Œ dataï¼Œçœ‹ä¸‹é¢ä¾‹å­

```js

props: {
  name: {
    type: String,
    default () {
      return 'renbo'
    }
  }
},
data:{
  return {
     age: 26
  }
},
methods: {
  sayHello () {
    console.log(this.name, this.age)
  }
}
```

è¿™å°±æ˜¯é€šè¿‡ proxy å°† props å’Œ data ä¸Šçš„å±æ€§ä»£ç†åˆ° vm å®ä¾‹ä¸Šï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ç›´æ¥é€šè¿‡ this è®¿é—®åˆ°

é‚£ä¹ˆæˆ‘ä»¬çœ‹çœ‹ proxy æ˜¯å¦‚ä½•å®šä¹‰çš„å‘¢

```js
export function proxy (target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

é€šè¿‡ Object.defineProperty æŠŠ target[sourceKey][key] çš„è¯»å†™å˜æˆäº†å¯¹ target[key] çš„è¯»å†™ï¼Œæ‰€ä»¥å¯¹äº props å’Œ data è€Œè¨€å°±æ˜¯

```js
vm._props.xxx -> vm.xxx
vm._data.xxx -> vm.xxx
```

### observe<hr>

ä¸Šé¢åœ¨ initDataä¸­è°ƒç”¨äº† observe å‡½æ•°ï¼Œè¿›å…¥æ–‡ä»¶ `src/core/observer/index.js` ä¸­

```js
**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
export function observe (value: any, asRootData: ?boolean): Observer | void {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  let ob: Observer | void
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value)
  }
  if (asRootData && ob) {
    ob.vmCount++
  }
  return ob
}
```

observe å°±æ˜¯ç»™é™¤äº† vnode çš„å¯¹è±¡ç±»å‹çš„æ•°æ®æ·»åŠ ä¸€ä¸ªè§‚å¯Ÿè€…å®ä¾‹

å¦‚æœå·²ç»æ·»åŠ è¿‡åˆ™ç›´æ¥è¿”å›ï¼Œå¦åˆ™åœ¨æ»¡è¶³ä¸€å®šæ¡ä»¶ä¸‹å» new Observer

æ¥ä¸‹æ¥æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ Observer çš„ä½œç”¨

```js
export class Observer {
  value: any;
  dep: Dep;
  vmCount: number; // number of vms that have this object as root $data

  constructor (value: any) {
    this.value = value
    this.dep = new Dep()
    this.vmCount = 0
    def(value, '__ob__', this)
    if (Array.isArray(value)) {
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        copyAugment(value, arrayMethods, arrayKeys)
      }
      this.observeArray(value)
    } else {
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */
  walk (obj: Object) {
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }

  /**
   * Observe a list of Array items.
   */
  observeArray (items: Array<any>) {
    for (let i = 0, l = items.length; i < l; i++) {
      observe(items[i])
    }
  }
}

```

Observer æ˜¯ä¸€ä¸ªæ„é€ å‡½æ•°
- åœ¨constructor ä¸­å®ä¾‹åŒ–äº† Dep å¯¹è±¡
- æ‰§è¡Œäº† `def(value, '__ob__', this)`
- å¯¹ value è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœæ˜¯æ•°ç»„è°ƒç”¨ observeArrayï¼Œå¦‚æœæ˜¯çº¯å¯¹è±¡è°ƒç”¨ walk 
- observeArray æ–¹æ³•ä¸­éå†æ•°ç»„å†æ¬¡è°ƒç”¨ observerï¼Œè€Œ walk éå†å¯¹è±¡çš„ key è°ƒç”¨ defineReactive

Dep ä¸»è¦çš„ä½œç”¨å°±æ˜¯è¿›è¡Œä¾èµ–æ”¶é›†ï¼Œæ˜¯æ•´ä¸ª getter çš„æ ¸å¿ƒï¼Œåœ¨åé¢ä¼šä»‹ç»ï¼Œdef å‡½æ•°æ˜¯é€šè¿‡ Object.defineProperty çš„å°è£…çš„ï¼Œä½œç”¨æ˜¯å°†è‡ªèº«å®ä¾‹æ·»åŠ åˆ°æ•°æ®å¯¹è±¡ value çš„ `__ob__` å±æ€§ä¸Šï¼Œè¿™æ ·æˆ‘ä»¬åœ¨å¼€å‘ä¸­å°±ä¼šçœ‹åˆ° data ä¸Šå¯¹è±¡ç±»å‹çš„æ•°æ®å¤šäº†ä¸€ä¸ª `__ob__ `çš„å±æ€§

### defineReactive<hr> 

defineReactive çš„ä½œç”¨å°±æ˜¯å®šä¹‰ä¸€ä¸ªå“åº”å¼å¯¹è±¡ï¼Œç»™å¯¹è±¡åŠ¨æ€æ·»åŠ  getter å’Œ setter

```js

/**
 * Define a reactive property on an Object.
 */
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      const value = getter ? getter.call(obj) : val
      if (Dep.target) {
        dep.depend()
        if (childOb) {
          childOb.dep.depend()
          if (Array.isArray(value)) {
            dependArray(value)
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) return
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}

```

defineReactive å‡½æ•°

-  new Dep()
-  é€šè¿‡ Object.getOwnPropertyDescriptor æ‹¿åˆ° obj çš„å±æ€§æè¿°ç¬¦
-  å¯¹å­å¯¹è±¡é€’å½’è°ƒç”¨ observe æ–¹æ³•ï¼ŒæŠŠæ‰€æœ‰å­å±æ€§å˜æˆå“åº”å¼å¯¹è±¡
-  åˆ©ç”¨ Object.defineProperty ç»™ obj çš„å±æ€§ key æ·»åŠ  getter å’Œ setter


ä¸‹é¢æˆ‘ä»¬é€šè¿‡ä¸Šé¢çš„é€»è¾‘æ­¥éª¤æ•´ç†ä¸‹é¢ä¸€å¼ å›¾

<img src="/assets/vue-observer.png" />

é€šè¿‡ä¸Šé¢çš„é€»è¾‘å’Œæ€»ç»“å‘ç°å“åº”å¼å¯¹è±¡çš„æ ¸å¿ƒå…¶å®å°±æ˜¯åˆ©ç”¨ Object.defineProperty ç»™æ•°æ®æ·»åŠ äº† getter å’Œ setterï¼Œæ¥è¿›è¡Œä¾èµ–æ”¶é›†`dep.depend()` å’Œæ´¾å‘æ›´æ–° `dep.notify()`

## ä¾èµ–æ”¶é›†

é€šè¿‡å“åº”å¼å¯¹è±¡æˆ‘ä»¬çŸ¥é“åœ¨ defineReactive å‡½æ•°å†…çš„ Object.defineProperty å®šä¹‰çš„ get å†…éƒ¨å®ä¾‹äº† Dep

### dep<hr>

```js
const dep = new Dep()
dep.depend()
```

å‰æ–‡è¯´è¿‡ Dep æ˜¯æ•´ä¸ª getter ä¾èµ–æ”¶é›†çš„æ ¸å¿ƒï¼Œæ‰“å¼€æ–‡ä»¶åœ¨ `src/core/observer/dep.js`

```js

// ...

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
export default class Dep {
  static target: ?Watcher;
  id: number;
  subs: Array<Watcher>;

  constructor () {
    this.id = uid++
    this.subs = []
  }

  addSub (sub: Watcher) {
    this.subs.push(sub)
  }

  removeSub (sub: Watcher) {
    remove(this.subs, sub)
  }

  depend () {
    if (Dep.target) {
      Dep.target.addDep(this)
    }
  }

  notify () {
    // stabilize the subscriber list first
    const subs = this.subs.slice()
    if (process.env.NODE_ENV !== 'production' && !config.async) {
      // subs aren't sorted in scheduler if not running async
      // we need to sort them now to make sure they fire in correct
      // order
      subs.sort((a, b) => a.id - b.id)
    }
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
const targetStack = []

export function pushTarget (_target: ?Watcher) {
  if (Dep.target) targetStack.push(Dep.target)
  Dep.target = _target
}

export function popTarget () {
  Dep.target = targetStack.pop()
}

```

### watcher<hr>

æˆ‘ä»¬æ¥çœ‹ä¸€ä¸‹ Dep ä¸­ä¸»è¦å°±æ˜¯å¯¹ Watcher çš„ä¸€ç§ç®¡ç†ï¼Œå…¶ä¸­ `subs: Array<Watcher>;` å°±æ˜¯è®¢é˜…è€…åˆ—è¡¨,åœ¨Watcher ä¸­è¿›è¡Œå®šä¹‰

æŸ¥çœ‹ `src/core/observer/watcher.js`

```js
let uid = 0

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
export default class Watcher {
  vm: Component;
  expression: string;
  cb: Function;
  id: number;
  deep: boolean;
  user: boolean;
  computed: boolean;
  sync: boolean;
  dirty: boolean;
  active: boolean;
  dep: Dep;
  deps: Array<Dep>;
  newDeps: Array<Dep>;
  depIds: SimpleSet;
  newDepIds: SimpleSet;
  before: ?Function;
  getter: Function;
  value: any;

  constructor (
    vm: Component,
    expOrFn: string | Function,
    cb: Function,
    options?: ?Object,
    isRenderWatcher?: boolean
  ) {
    this.vm = vm
    if (isRenderWatcher) {
      vm._watcher = this
    }
    vm._watchers.push(this)
    // options
    if (options) {
      this.deep = !!options.deep
      this.user = !!options.user
      this.computed = !!options.computed
      this.sync = !!options.sync
      this.before = options.before
    } else {
      this.deep = this.user = this.computed = this.sync = false
    }
    this.cb = cb
    this.id = ++uid // uid for batching
    this.active = true
    this.dirty = this.computed // for computed watchers
    this.deps = []
    this.newDeps = []
    this.depIds = new Set()
    this.newDepIds = new Set()
    this.expression = process.env.NODE_ENV !== 'production'
      ? expOrFn.toString()
      : ''
    // parse expression for getter
    if (typeof expOrFn === 'function') {
      this.getter = expOrFn
    } else {
      this.getter = parsePath(expOrFn)
      if (!this.getter) {
        this.getter = function () {}
        process.env.NODE_ENV !== 'production' && warn(
          `Failed watching path: "${expOrFn}" ` +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
          vm
        )
      }
    }
    if (this.computed) {
      this.value = undefined
      this.dep = new Dep()
    } else {
      this.value = this.get()
    }
  }

  /**
   * Evaluate the getter, and re-collect dependencies.
   */
  get () {
    pushTarget(this)
    let value
    const vm = this.vm
    try {
      value = this.getter.call(vm, vm)
    } catch (e) {
      if (this.user) {
        handleError(e, vm, `getter for watcher "${this.expression}"`)
      } else {
        throw e
      }
    } finally {
      // "touch" every property so they are all tracked as
      // dependencies for deep watching
      if (this.deep) {
        traverse(value)
      }
      popTarget()
      this.cleanupDeps()
    }
    return value
  }

  /**
   * Add a dependency to this directive.
   */
  addDep (dep: Dep) {
    const id = dep.id
    if (!this.newDepIds.has(id)) {
      this.newDepIds.add(id)
      this.newDeps.push(dep)
      if (!this.depIds.has(id)) {
        dep.addSub(this)
      }
    }
  }

  /**
   * Clean up for dependency collection.
   */
  cleanupDeps () {
    let i = this.deps.length
    while (i--) {
      const dep = this.deps[i]
      if (!this.newDepIds.has(dep.id)) {
        dep.removeSub(this)
      }
    }
    let tmp = this.depIds
    this.depIds = this.newDepIds
    this.newDepIds = tmp
    this.newDepIds.clear()
    tmp = this.deps
    this.deps = this.newDeps
    this.newDeps = tmp
    this.newDeps.length = 0
  }
  // ...
}
```

### ä¾èµ–æ”¶é›†è¿‡ç¨‹<hr>

å½“æˆ‘ä»¬åœ¨ mount è¿‡ç¨‹ä¸­è°ƒç”¨ mountComponent å‡½æ•°çš„æ—¶å€™å®ä¾‹åŒ–äº† `new Watcher`, ç„¶åæ‰§è¡Œäº† `this.get()` æ–¹æ³•
è¿›å…¥ get å‡½æ•° ä¼šæ‰§è¡Œ `pushTarget(this)`

æ‰“å¼€æ–‡ä»¶ `src/core/observer/dep.js` 

```js
export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}
```
pushTarget ä¸»è¦ä¸¤ä¸ªä½œç”¨ 
- æŠŠ Dep.target èµ‹å€¼ä¸ºå½“å‰çš„ Watcher
- å°† target è¿›è¡Œå‹æ ˆæ“ä½œ

æ¥ç€æ‰§è¡Œ

```js
value = this.getter.call(vm, vm)
```
this.getter å¯¹åº”å°±æ˜¯ updateComponent å‡½æ•°ï¼Œè¿™å®é™…ä¸Šå°±æ˜¯åœ¨æ‰§è¡Œï¼š

```js
vm._update(vm._render(), hydrating)
```

å®ƒä¼šå…ˆæ‰§è¡Œ vm._render() æ–¹æ³•ï¼Œç”Ÿæˆæ¸²æŸ“ VNodeï¼Œè®¿é—® vm ä¸Šçš„æ•°æ®ï¼Œè¿™æ ·å°±è§¦å‘äº†æ•°æ®å¯¹è±¡çš„ getterã€‚
æ¯ä¸ªgetter ä¸Šéƒ½æœ‰ä¸€ä¸ª dep ï¼Œè¿™æ ·å°±æ˜¯è°ƒç”¨ dep.depend() è¿›è¡Œä¾èµ–æ”¶é›†

```js
addDep (dep: Dep) {
  const id = dep.id
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id)
    this.newDeps.push(dep)
    if (!this.depIds.has(id)) {
      dep.addSub(this)
    }
  }
}

```

åœ¨ä¿è¯æ·»åŠ çš„æ•°æ®çš„å”¯ä¸€æ€§ åæ‰§è¡Œ `dep.addSub(this)`

ä¹Ÿå°±æ˜¯æ‰§è¡Œäº†`this.subs.push(sub)`

é€šè¿‡ä¸Šé¢çš„æ‰§è¡Œé¡ºåºï¼Œå½“å‰çš„ watcher å·²ç»è®¢é˜…åˆ°äº†æ•°æ® dep çš„ subs æ•°ç»„ä¸­ï¼Œå½“æ•°æ®æ”¾ç”Ÿæ”¹å˜åœ¨è¿›è¡Œ dep.notify

æ¥ä¸‹æ¥æ‰§è¡Œé€’å½’å»è®¿é—® valueï¼Œè§¦å‘å®ƒæ‰€æœ‰å­é¡¹çš„ getter

```js
if (this.deep) {
  traverse(value)
}
```

ä¹‹åæ‰§è¡Œ popTarget(),æ‰“å¼€æ–‡ä»¶ `src/core/observer/dep.js`

```js
export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}

```
è¿™ä¸ªæ—¶å€™ vm çš„æ•°æ®ä¾èµ–æ”¶é›†å·²ç»å®Œæˆéœ€è¦å°† Dep.target æ”¹å˜æˆä¸Šä¸€ä¸ªçŠ¶æ€ï¼Œå®Œæˆ  Dep.target æ¸²æŸ“ï¼Œæœ€åæ‰§è¡Œ`this.cleanupDeps()` è¿›è¡Œä¾èµ–æ¸…ç©º


```js
cleanupDeps () {
  let i = this.deps.length
  while (i--) {
    const dep = this.deps[i]
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this)
    }
  }
  let tmp = this.depIds
  this.depIds = this.newDepIds
  this.newDepIds = tmp
  this.newDepIds.clear()
  tmp = this.deps
  this.deps = this.newDeps
  this.newDeps = tmp
  this.newDeps.length = 0
}
```

åœ¨æ‰§è¡Œ cleanupDeps å‡½æ•°ï¼Œé¦–å…ˆéå† depsï¼Œç§»é™¤å¯¹ dep.subs æ•°ç»„ä¸­ Wathcer çš„è®¢é˜…ï¼ŒæŠŠ newDepIds å’Œ depIds äº¤æ¢ï¼ŒnewDeps å’Œ deps äº¤æ¢ï¼Œå¹¶æŠŠ newDepIds å’Œ newDeps æ¸…ç©ºï¼Œå› ä¸º newDeps æ˜¯æ–°æ·»åŠ çš„ Dep å®ä¾‹æ•°ç»„ï¼Œè€Œ deps è¡¨ç¤ºä¸Šä¸€æ¬¡æ·»åŠ çš„ Dep å®ä¾‹æ•°ç»„ï¼Œæ‰€ä»¥æ¯æ¬¡è®¢é˜…ï¼Œåœ¨subs ä¸­éƒ½æ˜¯æœ€æ–°çš„ï¼Œè¿™æ ·å°±å®Œæˆäº†æ•´ä¸ªä¾èµ–æ”¶é›†


## æ´¾å‘æ›´æ–°
é€šè¿‡ sub è¿™ä¸ªæ•°ç»„ï¼Œå½“æˆ‘ä»¬ä¿®æ”¹æ•°æ®çš„æ—¶å€™ï¼Œå°±å¯ä»¥æ›´æ–° sub æ•°ç»„ è¿›è¡Œæ´¾å‘æ›´æ–°ï¼Œä¸‹é¢åœ¨è¿›è¡Œä»£ç åˆ†æè¿™ä¸ªè¿‡ç¨‹
### setter é€»è¾‘<hr>

é€šè¿‡ `defineReactive` å‡½æ•°ä¸­ï¼Œå®šä¹‰å“åº”å¼çš„ setter è°ƒç”¨äº† `dep.notify()` æ¥é€šçŸ¥æ‰€æœ‰è®¢é˜…è€…ï¼Œæˆ‘ä»¬è¦æ›´æ–°äº†ã€‚

```js
export function defineReactive (
  obj: Object,
  key: string,
  val: any,
  customSetter?: ?Function,
  shallow?: boolean
) {
  const dep = new Dep()

  const property = Object.getOwnPropertyDescriptor(obj, key)
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  const getter = property && property.get
  const setter = property && property.set
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key]
  }

  let childOb = !shallow && observe(val)
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    // ...
    set: function reactiveSetter (newVal) {
      const value = getter ? getter.call(obj) : val
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (process.env.NODE_ENV !== 'production' && customSetter) {
        customSetter()
      }
      if (setter) {
        setter.call(obj, newVal)
      } else {
        val = newVal
      }
      childOb = !shallow && observe(newVal)
      dep.notify()
    }
  })
}
```

### æ´¾å‘æ›´æ–°è¿‡ç¨‹<hr>

å½“æˆ‘ä»¬ä¿®æ”¹äº†æ•°æ®ï¼Œè§¦å‘äº† setter ï¼Œè°ƒç”¨ `dep.notify()` ,éå†æ‰€æœ‰ subsï¼Œè°ƒç”¨ watcher çš„ update æ–¹æ³•

```js
// src/core/observer/dep.js
class Dep {
  // ...
  notify () {
  // stabilize the subscriber list first
    const subs = this.subs.slice()
    for (let i = 0, l = subs.length; i < l; i++) {
      subs[i].update()
    }
  }
}
```

```js
// src/core/observer/watcher.js
class Watcher {
  // ...
  update () {
    /* istanbul ignore else */
    if (this.computed) {
      // A computed property watcher has two modes: lazy and activated.
      // It initializes as lazy by default, and only becomes activated when
      // it is depended on by at least one subscriber, which is typically
      // another computed property or a component's render function.
      if (this.dep.subs.length === 0) {
        // In lazy mode, we don't want to perform computations until necessary,
        // so we simply mark the watcher as dirty. The actual computation is
        // performed just-in-time in this.evaluate() when the computed property
        // is accessed.
        this.dirty = true
      } else {
        // In activated mode, we want to proactively perform the computation
        // but only notify our subscribers when the value has indeed changed.
        this.getAndInvoke(() => {
          this.dep.notify()
        })
      }
    } else if (this.sync) {
      this.run()
    } else {
      queueWatcher(this)
    }
  }
}  
```

åœ¨è¿›è¡Œ update çš„æ—¶å€™ä¼šæ ¹æ®ä¸åŒåœºæ™¯å»æ´¾å‘æ›´æ–°ï¼Œcomputed ä¸ sync æˆ‘ä»¬æ”¾åœ¨åé¢æ¥è¯´ï¼Œè¿™ä¸¤ä¸ªçŠ¶æ€ä¹Ÿå°±æ˜¯æˆ‘ä»¬çš„è®¡ç®—å±æ€§ï¼ˆcomputedï¼‰å’Œä¾¦å¬å±æ€§ï¼ˆwatchï¼‰ï¼Œå…ˆçœ‹ä¸€ä¸‹ queueWatcher 

```js
// src/core/observer/scheduler.js

const queue: Array<Watcher> = []
let has: { [key: number]: ?true } = {}
let waiting = false
let flushing = false
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
```

ç”¨ has ä¿è¯åœ¨åŒä¸€ä¸ª watcher åªæ·»åŠ ä¸€æ¬¡ï¼Œå¹¶ä¸”åœ¨æ´¾å‘æ›´æ–°çš„æ—¶å€™æ¯æ¬¡æ•°æ®æ”¹å˜å¹¶ä¸ä¼šéƒ½è§¦å‘ watcher ï¼Œè€Œæ˜¯æŠŠwatcheræ·»åŠ åˆ°é˜Ÿåˆ—é‡Œé¢é€šè¿‡æ‰§è¡Œ nextTickï¼Œä¸‹é¢æ¥çœ‹ä¸€ä¸‹ `flushSchedulerQueue`

```js

// src/core/observer/scheduler.js

let flushing = false
let index = 0
/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  flushing = true
  let watcher, id

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort((a, b) => a.id - b.id)

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index]
    if (watcher.before) {
      watcher.before()
    }
    id = watcher.id
    has[id] = null
    watcher.run()
    // in dev build, check and stop circular updates.
    if (process.env.NODE_ENV !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? `in watcher with expression "${watcher.expression}"`
              : `in a component render function.`
          ),
          watcher.vm
        )
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  const activatedQueue = activatedChildren.slice()
  const updatedQueue = queue.slice()

  resetSchedulerState()

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue)
  callUpdatedHooks(updatedQueue)

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush')
  }
}
```


é¦–å…ˆæ‰§è¡Œå¯¹é˜Ÿåˆ—åšäº†ä»å°åˆ°å¤§çš„æ’åº

1. ç»„ä»¶çš„æ›´æ–°ç”±çˆ¶åˆ°å­ï¼›å› ä¸ºçˆ¶ç»„ä»¶çš„åˆ›å»ºè¿‡ç¨‹æ˜¯å…ˆäºå­çš„ï¼Œæ‰€ä»¥ watcher çš„åˆ›å»ºä¹Ÿæ˜¯å…ˆçˆ¶åå­ï¼Œæ‰§è¡Œé¡ºåºä¹Ÿåº”è¯¥ä¿æŒå…ˆçˆ¶åå­ã€‚

2. ç”¨æˆ·çš„è‡ªå®šä¹‰ watcher è¦ä¼˜å…ˆäºæ¸²æŸ“ watcher æ‰§è¡Œï¼›å› ä¸ºç”¨æˆ·è‡ªå®šä¹‰ watcher æ˜¯åœ¨æ¸²æŸ“ watcher ä¹‹å‰åˆ›å»ºçš„ã€‚

3. å¦‚æœä¸€ä¸ªç»„ä»¶åœ¨çˆ¶ç»„ä»¶çš„ watcher æ‰§è¡ŒæœŸé—´è¢«é”€æ¯ï¼Œé‚£ä¹ˆå®ƒå¯¹åº”çš„ watcher æ‰§è¡Œéƒ½å¯ä»¥è¢«è·³è¿‡ï¼Œæ‰€ä»¥çˆ¶ç»„ä»¶çš„ watcher åº”è¯¥å…ˆæ‰§è¡Œã€‚

å…¶æ¬¡è¿›è¡Œé˜Ÿåˆ—éå†

æ‹¿åˆ°å¯¹åº”çš„ watcherï¼Œæ‰§è¡Œ watcher.run()ã€‚å¦‚æœåœ¨éå†çš„æ—¶å€™ï¼Œç”¨æˆ·æœ‰å†æ·»åŠ æ–°çš„ watcher åŠ¨ä½œï¼Œ é‚£ä¹ˆå°±åœ¨é˜Ÿåˆ—ä¸­ä»åå¾€å‰æ‰¾ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªæ²¡æœ‰æ’å…¥çš„ watcher çš„ id æ¯”å½“å‰é˜Ÿåˆ—ä¸­ watcher çš„ id çš„å¤§çš„ä½ç½®ï¼Œæ”¾åˆ°é˜Ÿåˆ—ä¸­

```js
export function queueWatcher (watcher: Watcher) {
  const id = watcher.id
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // ...
  }
}
```

è¿™æ ·åœ¨æ‰§è¡Œ `watcher.run()` æ—¶å€™ï¼Œé€šè¿‡ `this.get()` å°±èƒ½å¾—åˆ° watcher å½“å‰çš„å€¼ï¼Œç„¶åé€šè¿‡åˆ¤æ–­ æ–°æ—§å€¼ä¸ç­‰ã€æ–°å€¼æ˜¯å¯¹è±¡ç±»å‹ã€deep æ¨¡å¼ä¸­çš„ä»»ä½•ä¸€ä¸ªæ¡ä»¶æˆç«‹éƒ½ä¼šè§¦å‘ watcher å›è°ƒï¼Œä¼ å…¥æ–°çš„ value å’Œ æ—§çš„ valueï¼Œè¿™æ ·æˆ‘ä»¬åœ¨æˆ‘ä»¬è‡ªå®šä¹‰ watcher çš„æ—¶å€™å°±å¯ä»¥åœ¨å›è°ƒå‡½æ•°ä¸­æ‹¿åˆ°ä¸¤ä¸ªå€¼ã€‚

å½“æˆ‘ä»¬æ•°æ®å‘ç”Ÿæ”¹å˜çš„æ—¶å€™ï¼Œè§¦å‘setter ï¼Œå› ä¸º watcher æ˜¯ä¸€ä¸ªé˜Ÿåˆ—ï¼Œé€šè¿‡è°ƒåº¦è¿›è¡Œäº†ä¼˜åŒ– åœ¨ nextTick åæ‰§è¡Œæ‰€æœ‰ `watcher` çš„ run ç„¶åè§¦å‘æ‰€æœ‰ watcher çš„ update è¿›è¡Œè¿›è¡Œ patch

### æ€»ç»“ <hr>

<img src="/assets/vue-dep.png">

é€šè¿‡ä¸Šé¢å‡ ä¸ªæ¨¡å—çš„åˆ†ææˆ‘ä»¬åŸºæœ¬çŸ¥é“äº† vue çš„å“åº”å¼è¿‡ç¨‹ï¼Œåœ¨ç”Ÿæˆå“åº”å¯¹è±¡çš„æ—¶å€™éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œvue æ›´æ–°å¯¹è±¡æ•°ç»„å¿…é¡»ç”¨ä»–çš„å…¨å±€æ–¹æ³•ä¹Ÿå°±æ˜¯ `vue.set,vue.get,vue.del` ç­‰ï¼Œå¦åˆ™æ˜¯ä¸ä¼šè§¦å‘setterï¼Œå¯¼è‡´è§†å›¾æ›´æ–°å¤±è´¥ã€‚


