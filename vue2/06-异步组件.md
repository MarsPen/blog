<h1 align="center">ğŸ“–å¼‚æ­¥ç»„ä»¶åˆ†æ</h1>

åœ¨æˆ‘ä»¬å¹³æ—¶çš„å¼€å‘å·¥ä½œä¸­ï¼Œä¸ºäº†å‡å°‘é¦–å±ä»£ç ä½“ç§¯ï¼Œå¾€å¾€ä¼šæŠŠä¸€äº›éé¦–å±çš„ç»„ä»¶è®¾è®¡æˆå¼‚æ­¥ç»„ä»¶ï¼ŒæŒ‰éœ€åŠ è½½ã€‚Vue ä¹ŸåŸç”Ÿæ”¯æŒäº†å¼‚æ­¥ç»„ä»¶çš„èƒ½åŠ›ï¼Œæœ‰ä¸‰ç§å®ç°æ–¹å¼

- æ™®é€šçš„å¼‚æ­¥ç»„ä»¶

```js 
Vue.component('async-example', function (resolve, reject) {
   // è¿™ä¸ªç‰¹æ®Šçš„ require è¯­æ³•å‘Šè¯‰ webpack
   // è‡ªåŠ¨å°†ç¼–è¯‘åçš„ä»£ç åˆ†å‰²æˆä¸åŒçš„å—ï¼Œ
   // è¿™äº›å—å°†é€šè¿‡ Ajax è¯·æ±‚è‡ªåŠ¨ä¸‹è½½ã€‚
   require(['./my-async-component'], resolve)
})
```

- Promise å¼‚æ­¥ç»„ä»¶

```js
Vue.component(
  'async-webpack-example',
  // è¯¥ `import` å‡½æ•°è¿”å›ä¸€ä¸ª `Promise` å¯¹è±¡ã€‚
  () => import('./my-async-component')
)
```

- é«˜çº§å¼‚æ­¥ç»„ä»¶

```js
const AsyncComp = () => ({
  // éœ€è¦åŠ è½½çš„ç»„ä»¶ã€‚åº”å½“æ˜¯ä¸€ä¸ª Promise
  component: import('./MyComp.vue'),
  // åŠ è½½ä¸­åº”å½“æ¸²æŸ“çš„ç»„ä»¶
  loading: LoadingComp,
  // å‡ºé”™æ—¶æ¸²æŸ“çš„ç»„ä»¶
  error: ErrorComp,
  // æ¸²æŸ“åŠ è½½ä¸­ç»„ä»¶å‰çš„ç­‰å¾…æ—¶é—´ã€‚é»˜è®¤ï¼š200msã€‚
  delay: 200,
  // æœ€é•¿ç­‰å¾…æ—¶é—´ã€‚è¶…å‡ºæ­¤æ—¶é—´åˆ™æ¸²æŸ“é”™è¯¯ç»„ä»¶ã€‚é»˜è®¤ï¼šInfinity
  timeout: 3000
})
Vue.component('async-example', AsyncComp)
```

é€šè¿‡ä¸Šé¢çš„ä¾‹å­ï¼Œæˆ‘ä»¬çŸ¥é“å¼‚æ­¥ç»„ä»¶çš„æ³¨å†Œä¸å†æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œè€Œæ˜¯ä¸€ä¸ªå·¥å‚å‡½æ•°ï¼Œæ‰€ä»¥ä¸ä¼šæ‰§è¡Œ Vue.extend çš„é€»è¾‘æŠŠå®ƒå˜æˆä¸€ä¸ªç»„ä»¶çš„æ„é€ å‡½æ•°ï¼Œä½†æ˜¯å®ƒä»ç„¶å¯ä»¥æ‰§è¡Œåˆ° createComponent å‡½æ•°ï¼Œé€šè¿‡createComponent æ–¹æ³•æ‰§è¡Œ `Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)`, å®ƒçš„å®šä¹‰åœ¨ `src/core/vdom/helpers/resolve-async-component.js` ä¸­

```js
export function resolveAsyncComponent (
  factory: Function,
  baseCtor: Class<Component>,
  context: Component
): Class<Component> | void {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context)
  } else {
    const contexts = factory.contexts = [context]
    let sync = true

    const forceRender = () => {
      for (let i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate()
      }
    }

    const resolve = once((res: Object | Class<Component>) => {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor)
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender()
      }
    })

    const reject = once(reason => {
      process.env.NODE_ENV !== 'production' && warn(
        `Failed to resolve async component: ${String(factory)}` +
        (reason ? `\nReason: ${reason}` : '')
      )
      if (isDef(factory.errorComp)) {
        factory.error = true
        forceRender()
      }
    })

    const res = factory(resolve, reject)

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject)
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject)

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor)
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor)
          if (res.delay === 0) {
            factory.loading = true
          } else {
            setTimeout(() => {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true
                forceRender()
              }
            }, res.delay || 200)
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(() => {
            if (isUndef(factory.resolved)) {
              reject(
                process.env.NODE_ENV !== 'production'
                  ? `timeout (${res.timeout}ms)`
                  : null
              )
            }
          }, res.timeout)
        }
      }
    }

    sync = false
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}
```

é€šè¿‡ä¸Šé¢ä»£ç æˆ‘ä»¬å¾ˆç›´è§‚çš„å¯ä»¥çœ‹åˆ°å¼‚æ­¥ç»„ä»¶å®šä¹‰äº† forceRenderã€resolve å’Œ reject å‡½æ•°æ¥æ‰§è¡Œå¼‚æ­¥ç»„ä»¶ã€‚å¦‚æœå¼‚æ­¥ç»„ä»¶æ‰§è¡ŒæˆåŠŸå°±ä¼šæ‰§è¡Œ resolve å‡½æ•°ï¼Œå†é€šè¿‡ forceUpdate çš„é€»è¾‘è°ƒç”¨æ¸²æŸ“ watcher çš„ update æ–¹æ³•ï¼Œè®©æ¸²æŸ“ watcher å¯¹åº”çš„å›è°ƒå‡½æ•°æ‰§è¡Œï¼Œå¼ºåˆ¶è§¦å‘äº†ç»„ä»¶çš„é‡æ–°æ¸²æŸ“ã€‚å› ä¸ºå¼‚æ­¥ç»„ä»¶åŠ è½½è¿‡ç¨‹ä¸­æ˜¯æ²¡æœ‰æ•°æ®å‘ç”Ÿå˜åŒ–çš„ï¼Œæ‰€ä»¥é€šè¿‡æ‰§è¡Œ $forceUpdate å¯ä»¥å¼ºåˆ¶ç»„ä»¶é‡æ–°æ¸²æŸ“ä¸€æ¬¡ã€‚è¿™æ ·å…¶å®å¼‚æ­¥ç»„ä»¶æœ¬è´¨æ˜¯ä¸¤æ¬¡æ¸²æŸ“ã€‚å¦‚æœå¤±è´¥æˆ–è€…æ˜¯é”™è¯¯åˆ™æ‰§è¡Œ reject å‡½æ•°













