
<h1 align="center">ğŸ“–ç»„ä»¶æ›´æ–°åˆ†æ</h1>

æˆ‘ä»¬å¯¹å“åº”å¼åŸç†è¿›è¡Œäº†æ¢³ç†ï¼ŒçŸ¥é“äº†å½“æ•°æ®å‘ç”Ÿå˜åŒ–ä¼šè§¦å‘ watcher çš„å›è°ƒï¼Œè¿›è¡Œç»„ä»¶æ›´æ–°ï¼Œé‚£ä¹ˆæ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹æ›´æ–°çš„æ“ä½œæ˜¯æ€ä¹ˆè¿›è¡Œäº†ã€‚`src/core/instance/lifecycle.js` ä¸­ `vm._update` æ–¹æ³•

### vm._update <hr>

```js
Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) {
  const vm: Component = this
  // ...
  const prevVnode = vm._vnode
  if (!prevVnode) {
     // initial render
    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)
  } else {
    // updates
    vm.$el = vm.__patch__(prevVnode, vnode)
  }
  // ...
}
```

###  vm.__patch__ <hr>

`vm._update` æ–¹æ³•ä¸»è¦é€šè¿‡èŠ‚ç‚¹æ¥åˆ¤æ–­ä¼ å…¥çš„å‚æ•°ï¼Œä½†æ˜¯æ‰§è¡Œçš„æ–¹æ³•éƒ½æ˜¯ `vm.__patch__`,æ¥ä¸‹æˆ‘ä»¬çœ‹ä¸€ä¸‹ `src/core/vdom/patch.js` ä¸­ patch å‡½æ•°

 ```js
return function patch (oldVnode, vnode, hydrating, removeOnly) {
  if (isUndef(vnode)) {
    if (isDef(oldVnode)) invokeDestroyHook(oldVnode)
    return
  }

  let isInitialPatch = false
  const insertedVnodeQueue = []

  if (isUndef(oldVnode)) {
    // empty mount (likely as component), create new root element
    isInitialPatch = true
    createElm(vnode, insertedVnodeQueue)
  } else {
    const isRealElement = isDef(oldVnode.nodeType)
    if (!isRealElement && sameVnode(oldVnode, vnode)) {
      // patch existing root node
      patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
    } else {
      if (isRealElement) {
         // ...
      }

      // replacing existing element
      const oldElm = oldVnode.elm
      const parentElm = nodeOps.parentNode(oldElm)

      // create new node
      createElm(
        vnode,
        insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm,
        nodeOps.nextSibling(oldElm)
      )

      // update parent placeholder node element, recursively
      if (isDef(vnode.parent)) {
        let ancestor = vnode.parent
        const patchable = isPatchable(vnode)
        while (ancestor) {
          for (let i = 0; i < cbs.destroy.length; ++i) {
            cbs.destroy[i](ancestor)
          }
          ancestor.elm = vnode.elm
          if (patchable) {
            for (let i = 0; i < cbs.create.length; ++i) {
              cbs.create[i](emptyNode, ancestor)
            }
            // #6513
            // invoke insert hooks that may have been merged by create hooks.
            // e.g. for directives that uses the "inserted" hook.
            const insert = ancestor.data.hook.insert
            if (insert.merged) {
              // start at index 1 to avoid re-invoking component mounted hook
              for (let i = 1; i < insert.fns.length; i++) {
                insert.fns[i]()
              }
            }
          } else {
            registerRef(ancestor)
          }
          ancestor = ancestor.parent
        }
      }

      // destroy old node
      if (isDef(parentElm)) {
        removeVnodes(parentElm, [oldVnode], 0, 0)
      } else if (isDef(oldVnode.tag)) {
        invokeDestroyHook(oldVnode)
      }
    }
  }

  invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch)
  return vnode.elm
}
 ```


 å¯ä»¥çœ‹åˆ° patch çš„é€»è¾‘è¿›æ¥é€šè¿‡åˆ¤æ–­æ˜¯å¦æœ‰ oldVnode æ¥åŒºåˆ†æ˜¯å¦æ˜¯é¦–æ¬¡æ¸²æŸ“ï¼Œè¿›è¡Œä¸åŒçš„é€»è¾‘ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬é€šè¿‡  `sameVNode(oldVnode, vnode)` 

```js
function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}
```

æ ¹æ® vnode çš„ key è¿›è¡Œåˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„ï¼Œå†ç»§ç»­æ ¹æ® isCommentã€dataã€sameInputType çš„ç±»å‹æ˜¯å¦ç›¸åŒæ¥åˆ¤æ–­åŒæ­¥ç»„ä»¶ï¼Œå¯¹äºå¼‚æ­¥ç»„ä»¶åˆ™é€šè¿‡åˆ¤æ–­ asyncFactory æ˜¯å¦ç›¸åŒï¼Œæ‰€ä»¥æ˜¯æ ¹æ®åˆ¤æ–­å®ƒä»¬æ˜¯å¦æ˜¯ç›¸åŒçš„ vnode æ¥åŒºåˆ†ä¸åŒçš„æ›´æ–°é€»è¾‘

### æ–°æ—§èŠ‚ç‚¹ä¸åŒ<hr>

å¦‚æœæ–°æ—§èŠ‚ç‚¹ä¸åŒ,é‚£ä¹ˆå°±æ˜¯æ›¿æ¢å·²ç»å­˜åœ¨çš„èŠ‚ç‚¹å¤§è‡´æµç¨‹ä¸º

- åˆ›å»ºæ–°èŠ‚ç‚¹
- æ›´æ–°çˆ¶çš„å ä½ç¬¦èŠ‚ç‚¹
- åˆ é™¤æ—§èŠ‚ç‚¹

```js
const oldElm = oldVnode.elm
const parentElm = nodeOps.parentNode(oldElm)
// create new node
createElm(
  vnode,
  insertedVnodeQueue,
  // extremely rare edge case: do not insert if old element is in a
  // leaving transition. Only happens when combining  transition +
  // keep-alive + HOCs. (#4590)
  oldElm._leaveCb ? null : parentElm,
  nodeOps.nextSibling(oldElm)
)
```
åˆ›å»ºæ–°èŠ‚ç‚¹è°ƒç”¨çš„æ˜¯ createElm æ–¹æ³•ï¼Œ ä»¥å½“å‰æ—§èŠ‚ç‚¹ä¸ºå‚è€ƒï¼Œåˆ›å»ºæ–°çš„èŠ‚ç‚¹ï¼Œå¹¶æ’å…¥åˆ° DOM ä¸­

```js
// update parent placeholder node element, recursively
if (isDef(vnode.parent)) {
  let ancestor = vnode.parent
  const patchable = isPatchable(vnode)
  while (ancestor) {
    for (let i = 0; i < cbs.destroy.length; ++i) {
      cbs.destroy[i](ancestor)
    }
    ancestor.elm = vnode.elm
    if (patchable) {
      for (let i = 0; i < cbs.create.length; ++i) {
        cbs.create[i](emptyNode, ancestor)
      }
      // #6513
      // invoke insert hooks that may have been merged by create hooks.
      // e.g. for directives that uses the "inserted" hook.
      const insert = ancestor.data.hook.insert
      if (insert.merged) {
        // start at index 1 to avoid re-invoking component mounted hook
        for (let i = 1; i < insert.fns.length; i++) {
          insert.fns[i]()
        }
      }
    } else {
      registerRef(ancestor)
    }
    ancestor = ancestor.parent
  }
}
```

æ‰¾åˆ°å½“å‰çš„ vnode çš„ çˆ¶çš„å ä½ç¬¦èŠ‚ç‚¹ï¼Œå…ˆæ‰§è¡Œ cbs.destroy é’©å­å‡½æ•°ï¼Œå¦‚æœå½“å‰å ä½ç¬¦æ˜¯ä¸€ä¸ªå¯æŒ‚è½½çš„èŠ‚ç‚¹ï¼Œåˆ™æ‰§è¡Œ cbs.create é’©å­å‡½æ•°

```js
// destroy old node
if (isDef(parentElm)) {
  removeVnodes(parentElm, [oldVnode], 0, 0)
} else if (isDef(oldVnode.tag)) {
  invokeDestroyHook(oldVnode)
}
```

å°† oldVnode ä»å½“å‰ DOM æ ‘ä¸­åˆ é™¤ï¼Œå¦‚æœå­˜åœ¨çˆ¶èŠ‚ç‚¹ï¼Œæ‰§è¡Œ removeVnodes æ–¹æ³•

```js
function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
  for (; startIdx <= endIdx; ++startIdx) {
    const ch = vnodes[startIdx]
    if (isDef(ch)) {
      if (isDef(ch.tag)) {
        removeAndInvokeRemoveHook(ch)
        invokeDestroyHook(ch)
      } else { // Text node
        removeNode(ch.elm)
      }
    }
  }
}

function removeAndInvokeRemoveHook (vnode, rm) {
  if (isDef(rm) || isDef(vnode.data)) {
    let i
    const listeners = cbs.remove.length + 1
    if (isDef(rm)) {
      // we have a recursively passed down rm callback
      // increase the listeners count
      rm.listeners += listeners
    } else {
      // directly removing
      rm = createRmCb(vnode.elm, listeners)
    }
    // recursively invoke hooks on child component root node
    if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
      removeAndInvokeRemoveHook(i, rm)
    }
    for (i = 0; i < cbs.remove.length; ++i) {
      cbs.remove[i](vnode, rm)
    }
    if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
      i(vnode, rm)
    } else {
      rm()
    }
  } else {
    removeNode(vnode.elm)
  }
}

function invokeDestroyHook (vnode) {
  let i, j
  const data = vnode.data
  if (isDef(data)) {
    if (isDef(i = data.hook) && isDef(i = i.destroy)) i(vnode)
    for (i = 0; i < cbs.destroy.length; ++i) cbs.destroy[i](vnode)
  }
  if (isDef(i = vnode.children)) {
    for (j = 0; j < vnode.children.length; ++j) {
      invokeDestroyHook(vnode.children[j])
    }
  }
}
```

- éå†å¾…åˆ é™¤çš„ vnodes åšåˆ é™¤ï¼Œ
- è°ƒç”¨ removeAndInvokeRemoveHook æ‰§è¡Œ cbs.remove é’©å­è¿›è¡Œåˆ é™¤ã€‚å¦‚æœå­˜åœ¨å­èŠ‚ç‚¹åˆ™è¿›è¡Œé€’å½’è°ƒç”¨ removeAndInvokeRemoveHook
- è°ƒç”¨ invokeDestroyHook æ‰§è¡Œ cbs.destroy é’©å­ï¼Œè¿›è¡Œé”€æ¯ã€‚å¦‚æœå­˜åœ¨å­èŠ‚ç‚¹åˆ™è¿›è¡Œé€’å½’è°ƒç”¨ invokeDestroyHook
- æ‰§è¡Œ removeNode è°ƒç”¨å¹³å°çš„ DOM API åˆ é™¤çœŸæ­£çš„ DOM èŠ‚ç‚¹


### æ–°æ—§èŠ‚ç‚¹ç›¸åŒ<hr>

```js
 if (!isRealElement && sameVnode(oldVnode, vnode)) {
    // patch existing root node
    patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)
  } else {
    // ...
  }
```

å½“æ–°æ—§èŠ‚ç‚¹ç›¸åŒçš„æ—¶å€™,ä¼šè°ƒç”¨ patchVnode æ–¹æ³•

```js
function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) {
  if (oldVnode === vnode) {
    return
  }

  const elm = vnode.elm = oldVnode.elm

  if (isTrue(oldVnode.isAsyncPlaceholder)) {
    if (isDef(vnode.asyncFactory.resolved)) {
      hydrate(oldVnode.elm, vnode, insertedVnodeQueue)
    } else {
      vnode.isAsyncPlaceholder = true
    }
    return
  }

  // reuse element for static trees.
  // note we only do this if the vnode is cloned -
  // if the new node is not cloned it means the render functions have been
  // reset by the hot-reload-api and we need to do a proper re-render.
  if (isTrue(vnode.isStatic) &&
    isTrue(oldVnode.isStatic) &&
    vnode.key === oldVnode.key &&
    (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
  ) {
    vnode.componentInstance = oldVnode.componentInstance
    return
  }

  let i
  const data = vnode.data
  if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
    i(oldVnode, vnode)
  }

  const oldCh = oldVnode.children
  const ch = vnode.children
  if (isDef(data) && isPatchable(vnode)) {
    for (i = 0; i < cbs.update.length; ++i) cbs.update[i](oldVnode, vnode)
    if (isDef(i = data.hook) && isDef(i = i.update)) i(oldVnode, vnode)
  }
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, '')
    }
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text)
  }
  if (isDef(data)) {
    if (isDef(i = data.hook) && isDef(i = i.postpatch)) i(oldVnode, vnode)
  }
}
```

patchVnode å°† vnode patch åˆ°æ—§çš„ vnode ä¸Šå°†æ‰§è¡Œä»¥ä¸‹ä¸»è¦è¿‡ç¨‹
- å¦‚æœä¸¤ä¸ªvnodeç›¸ç­‰ï¼Œä¸éœ€è¦ patch
- å¦‚æœæ˜¯å¼‚æ­¥å ä½ï¼Œæ‰§è¡Œ hydrate æ–¹æ³•æˆ–è€…å®šä¹‰ isAsyncPlaceholder ä¸º true
- å½“æ›´æ–°çš„ vnode æ˜¯ç»„ä»¶ vnode çš„æ—¶å€™ï¼Œ æ‰§è¡Œ i.prepatch é’©å­å‡½æ•°ï¼Œæ‹¿åˆ°æœ€æ–°çš„ vnode ç»„ä»¶é…ç½®ä»¥åŠç»„ä»¶çš„å®ä¾‹åï¼Œæ‰§è¡Œ updateChildComponent æ–¹æ³•æ›´æ–° vm å®ä¾‹ä¸Šä¸€ç³»åˆ—çš„å±æ€§å’Œæ–¹æ³•
- æ‰§è¡Œ cbs.update é’©å­å‡½æ•°
- å®Œæˆ patch è¿‡ç¨‹
- æ‰§è¡Œ postpatch é’©å­å‡½æ•°

ä¸Šé¢æ‰§è¡Œçš„æ­¥éª¤æˆ‘ä»¬é‡ç‚¹å…³æ³¨ä¸€ä¸‹å®Œæˆ patch çš„è¿‡ç¨‹ï¼Œè¿™ä¹Ÿæ˜¯ vnode diff æœ€å¤æ‚çš„åœ°æ–¹

```js
  if (isUndef(vnode.text)) {
    if (isDef(oldCh) && isDef(ch)) {
      if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)
    } else if (isDef(ch)) {
      if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, '')
      addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)
    } else if (isDef(oldCh)) {
      removeVnodes(elm, oldCh, 0, oldCh.length - 1)
    } else if (isDef(oldVnode.text)) {
      nodeOps.setTextContent(elm, '')
    }
  } else if (oldVnode.text !== vnode.text) {
    nodeOps.setTextContent(elm, vnode.text)
  }
```

- å¦‚æœ vnode æ˜¯ä¸ªæ–‡æœ¬èŠ‚ç‚¹ä¸”æ–°æ—§æ–‡æœ¬ä¸ç›¸åŒï¼Œåˆ™ç›´æ¥æ›¿æ¢æ–‡æœ¬å†…å®¹ï¼Œå¦åˆ™æ ¹æ®ä¸åŒæƒ…å†µå¤„ç†é€»è¾‘
- oldCh ä¸ ch éƒ½å­˜åœ¨ä¸”ä¸ç›¸åŒæ—¶ï¼Œè°ƒç”¨ updateChildren æ¥æ›´æ–°å­èŠ‚ç‚¹
- å½“åªæœ‰ ch å­˜åœ¨ï¼Œåˆ¤æ–­æ—§çš„èŠ‚ç‚¹æ˜¯æ–‡æœ¬èŠ‚ç‚¹åˆ™å…ˆå°†èŠ‚ç‚¹çš„æ–‡æœ¬æ¸…é™¤ï¼Œç„¶åé€šè¿‡ addVnodes å°† ch æ‰¹é‡æ’å…¥åˆ°æ–°èŠ‚ç‚¹ elm ä¸‹ï¼Œè¡¨ç¤ºä¸éœ€è¦æ—§èŠ‚ç‚¹äº†
- å½“åªæœ‰ oldCh å­˜åœ¨ï¼Œå°†æ—§çš„èŠ‚ç‚¹é€šè¿‡ removeVnodes å…¨éƒ¨æ¸…é™¤ï¼Œè¡¨ç¤ºæ›´æ–°çš„æ˜¯ç©ºèŠ‚ç‚¹
- å½“åªæœ‰æ—§èŠ‚ç‚¹æ˜¯æ–‡æœ¬èŠ‚ç‚¹çš„æ—¶å€™ï¼Œåˆ™æ¸…é™¤å…¶èŠ‚ç‚¹æ–‡æœ¬å†…å®¹

### updateChildren <hr>
ä¸Šé¢åœ¨åˆ¤æ–­ oldCh ä¸ ch éƒ½å­˜åœ¨ä¸”ä¸ç›¸åŒæ—¶è°ƒç”¨ updateChildren æ¥æ›´æ–°å­èŠ‚ç‚¹ï¼Œæ¥ä¸‹æ¥æˆ‘ä»¬çœ‹çœ‹è¿™ä¸ªå‡½æ•°

```js
function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let oldStartVnode = oldCh[0] 
  let oldEndVnode = oldCh[oldEndIdx] 
  let newEndIdx = newCh.length - 1 
  let newStartVnode = newCh[0]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx, idxInOld, vnodeToMove, refElm

  
  // removeOnly æ˜¯ä¸€ä¸ªåªç”¨äº <transition-group> çš„ç‰¹æ®Šæ ‡ç­¾ï¼Œ
  // ç¡®ä¿ç§»é™¤å…ƒç´ è¿‡ç¨‹ä¸­ä¿æŒä¸€ä¸ªæ­£ç¡®çš„ç›¸å¯¹ä½ç½®ã€‚
  const canMove = !removeOnly

  if (process.env.NODE_ENV !== 'production') {
    checkDuplicateKeys(newCh)
  }

  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
      // å¼€å§‹è€ vnode å‘å³ä¸€ä½
      oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
      // ç»“æŸè€ vnode å‘å·¦ä¸€ä½
      oldEndVnode = oldCh[--oldEndIdx]
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
      // æ–°æ—§å¼€å§‹ vnode ç›¸ä¼¼ï¼Œè¿›è¡Œpacthã€‚å¼€å§‹ vnode å‘å³ä¸€ä½
      patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
      // æ–°æ—§ç»“æŸ vnode ç›¸ä¼¼ï¼Œè¿›è¡Œpatchã€‚ç»“æŸ vnode å‘å·¦ä¸€ä½
      patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
      // æ–°ç»“æŸ vnode å’Œè€å¼€å§‹ vnode ç›¸ä¼¼ï¼Œè¿›è¡Œpatchã€‚
      patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
      // è€å¼€å§‹ vnode æ’å…¥åˆ°çœŸå® DOM ä¸­ï¼Œè€å¼€å§‹ vnode å‘å³ä¸€ä½ï¼Œæ–°ç»“æŸ vnode å‘å·¦ä¸€ä½
      canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
     // è€ç»“æŸ vnode å’Œæ–°å¼€å§‹ vnode ç›¸ä¼¼ï¼Œè¿›è¡Œ patchã€‚
      patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
      // è€ç»“æŸ vnode æ’å…¥åˆ°çœŸå® DOM ä¸­ï¼Œè€ç»“æŸ vnode å‘å·¦ä¸€ä½ï¼Œæ–°å¼€å§‹ vnode å‘å³ä¸€ä½
      canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      // è·å–è€ Idx çš„ key
      if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      // ç»™è€ idx èµ‹å€¼
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (isUndef(idxInOld)) { // New element
        // å¦‚æœè€ idx ä¸º undefinedï¼Œè¯´æ˜æ²¡æœ‰è¿™ä¸ªå…ƒç´ ï¼Œåˆ›å»ºæ–° DOM å…ƒç´ ã€‚
        createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
      } else {
        // è·å– vnode
        vnodeToMove = oldCh[idxInOld]
        if (sameVnode(vnodeToMove, newStartVnode)) {
          // å¦‚æœç”Ÿæˆçš„ vnode å’Œæ–°å¼€å§‹ vnode ç›¸ä¼¼ï¼Œæ‰§è¡Œ patchã€‚
          patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
          // èµ‹å€¼ undefinedï¼Œæ’å…¥ vnodeToMove å…ƒç´ 
          oldCh[idxInOld] = undefined
          canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
        } else {
          // ç›¸åŒçš„keyä¸åŒçš„å…ƒç´ ï¼Œè§†ä¸ºæ–°å…ƒç´ 
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        }
      }
      // æ–°å¼€å§‹ vnode å‘å³ä¸€ä½
      newStartVnode = newCh[++newStartIdx]
    }
  }
  // å¦‚æœè€å¼€å§‹ idx å¤§äºè€ç»“æŸ idxï¼Œå¦‚æœæ˜¯æœ‰æ•ˆæ•°æ®åˆ™æ·»åŠ  vnode åˆ°æ–° vnode ä¸­ã€‚
  if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
  } else if (newStartIdx > newEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}
```


ä¸Šé¢çš„é€»è¾‘æ¯”è¾ƒå¤æ‚ï¼Œæˆ‘ä»¬é€šè¿‡ä¸€ä¸ªç®€å•çš„ä¾‹å­å…ˆæ¥çœ‹ä¸€ä¸‹
```js
<div id="app">
  <div>
    <ul>
      <li v-for="item in items" :key="item.id">{{ item.val }}</li>
    </ul>
  </div>
  <button @click="change">ç‚¹å‡»æˆ‘</button>
</div>

<script>
  var app = new Vue({
    el: '#app',
    data: {
      items: [
        { id: 0, val: 'A' },
        { id: 1, val: 'B' },
        { id: 2, val: 'C' },
        { id: 3, val: 'D' }
      ]
    },
    methods: {
      change() {
        this.items.reverse().push({ id: 4, val: 'E' })
      }
    }
  })
</script>
```

ä¸Šé¢çš„ä»£ç å¾ˆç®€å•å°±æ˜¯åˆå§‹åŒ–çš„æ—¶å€™æ¸²æŸ“åˆ—è¡¨ä¸º Aã€Bã€Cã€Dï¼Œå½“ç‚¹å‡»çš„æ—¶å€™å°†æ•°æ®ä¸­ push ä¸€ä¸ª E å¹¶ä¸”è¿›è¡Œåè½¬ï¼Œç»“æœä¸º Dã€Cã€Bã€Aã€E é‚£ä¹ˆå…·ä½“æ€ä¹ˆæ›´æ–°çš„å‘¢ï¼Œçœ‹ä¸€ä¸‹ä¸‹é¢çš„æµç¨‹

ç¬¬ä¸€æ­¥:
<img src="/assets/vue-dom-diff01.png">

ç¬¬äºŒæ­¥:
<img src="/assets/vue-dom-diff02.png">

ç¬¬ä¸‰æ­¥:
<img src="/assets/vue-dom-diff03.png">

ç¬¬å››æ­¥:
<img src="/assets/vue-dom-diff04.png">

ç¬¬äº”æ­¥:
<img src="/assets/vue-dom-diff05.png">

ç¬¬å…­æ­¥:
<img src="/assets/vue-dom-diff06.png">


é€šè¿‡ä¸Šé¢æµç¨‹å›¾ï¼Œæˆ‘ä»¬å¾ˆæ¸…æ™°çš„çŸ¥é“å®é™…ä¸Šå°±æ˜¯æ–°æ—§èŠ‚ç‚¹å¯¹æ¯”ç§»åŠ¨çš„è¿‡ç¨‹é‚£ä¹ˆæˆ‘ä»¬æ‹†åˆ† updateChildren å‡½æ•°

> åˆå§‹åŒ–å…¨å±€å˜é‡

```js
  let oldStartIdx = 0  // æ—§èŠ‚ç‚¹ç´¢å¼•å¼€å§‹ä½ç½®
  let newStartIdx = 0 // æ–°èŠ‚ç‚¹ç´¢å¼•å¼€å§‹ä½ç½®
  let oldEndIdx = oldCh.length - 1 // æ—§èŠ‚ç‚¹ç´¢å¼•ç»ˆç‚¹ä½ç½®
  let oldStartVnode = oldCh[0] //  æ—§èŠ‚ç‚¹å¼€å§‹å€¼
  let oldEndVnode = oldCh[oldEndIdx] // æ—§èŠ‚ç‚¹æœ€åä¸€ä½çš„å€¼
  let newEndIdx = newCh.length - 1 // æ–°èŠ‚ç‚¹ç´¢å¼•ç»“æŸä½ç½®
  let newStartVnode = newCh[0] // æ–°èŠ‚ç‚¹å¼€å§‹å€¼
  let newEndVnode = newCh[newEndIdx] // æ–°èŠ‚ç‚¹ç»“æŸçš„å€¼
```

> å®šä¹‰å¾ªç¯ï¼Œåœ¨éå†è¿‡ç¨‹ä¸­ï¼ŒoldStartIdx å’Œ newStartIdx é€’å¢ï¼ŒoldEndIdx å’Œ newEndIdx é€’å‡ã€‚å½“æ¡ä»¶ä¸ç¬¦åˆè·³å‡ºéå†å¾ªç¯

```js
while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
  // ...
}
```

> æ£€æµ‹ oldStartVnodeã€oldEndVnodeã€‚å¦‚æœ oldStartVnode ä¸å­˜åœ¨ï¼ŒoldCh èµ·å§‹ç‚¹å‘åç§»åŠ¨ã€‚å¦‚æœ oldEndVnode ä¸å­˜åœ¨ï¼ŒoldCh ç»ˆæ­¢ç‚¹å‘å‰ç§»åŠ¨ã€‚

```js
if (isUndef(oldStartVnode)) {
  oldStartVnode = oldCh[++oldStartIdx]
} else if (isUndef(oldEndVnode)) {
  oldEndVnode = oldCh[--oldEndIdx]
}
```

> å¯¹æ¯” oldStartVnode å’Œ newStartVnode å¦‚æœä¸ºçœŸåˆ™æ‰§è¡Œ patchVnode åŒæ—¶å½¼æ­¤å‘åç§»åŠ¨ä¸€ä½

```js
else if (sameVnode(oldStartVnode, newStartVnode)) {
  patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)
  oldStartVnode = oldCh[++oldStartIdx]
  newStartVnode = newCh[++newStartIdx]
}
```

>  å¯¹æ¯” oldEndVnode å’Œ newEndVnode å¦‚æœä¸ºçœŸåˆ™æ‰§è¡Œ patchVnode åŒæ—¶å½¼æ­¤å‘å‰ç§»åŠ¨ä¸€ä½

```js
else if (sameVnode(oldEndVnode, newEndVnode)) {
  patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)
  oldEndVnode = oldCh[--oldEndIdx]
  newEndVnode = newCh[--newEndIdx]
}
```

> å¯¹æ¯” oldStartVnode å’Œ newEndVnode å¦‚æœä¸ºçœŸåˆ™æ‰§è¡Œ patchVnodeï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹ç§»åŠ¨åˆ° vnode æ•°ç»„æœ€åä¸€ä½

```js
else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
  patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)
  canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
  oldStartVnode = oldCh[++oldStartIdx]
  newEndVnode = newCh[--newEndIdx]
}
```

> å¯¹æ¯” oldEndVnode å’Œ newStartVnode å¦‚æœä¸ºçœŸåˆ™æ‰§è¡Œ patchVnodeï¼Œç„¶åå°†è¯¥èŠ‚ç‚¹ç§»åŠ¨åˆ° vnode æ•°ç»„ç¬¬ä¸€ä½

```js
else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
  patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)
  canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
  oldEndVnode = oldCh[--oldEndIdx]
  newStartVnode = newCh[++newStartIdx]
}
```
> å¯¹æ¯” idx å¦‚æœæ²¡æœ‰ç›¸åŒçš„ idx åˆ™æ‰§è¡Œ createElm åˆ›å»ºå…ƒç´ ã€‚

```js
if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
idxInOld = isDef(newStartVnode.key)
  ? oldKeyToIdx[newStartVnode.key]
  : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
if (isUndef(idxInOld)) { // New element
  createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
}
```

>  å¯¹æ¯” idx å¦‚æœä¸¤ä¸ª vnode ç›¸ä¼¼ï¼Œåˆ™å…ˆæ‰§è¡Œ patchVnodeï¼ŒèŠ‚ç‚¹ç§»åŠ¨åˆ° vnode æ•°ç»„ç¬¬ä¸€ä½ã€‚å¦‚æœä¸¤ä¸ª vnode ä¸ç›¸ä¼¼ï¼Œè§†ä¸ºæ–°å…ƒç´ ï¼Œæ‰§è¡Œ createElm åˆ›å»º

```js
vnodeToMove = oldCh[idxInOld]
if (sameVnode(vnodeToMove, newStartVnode)) {
  patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)
  oldCh[idxInOld] = undefined
  canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
} else {
 // same key but different element. treat as new element
 createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm)
}
newStartVnode = newCh[++newStartIdx]
```

>  å¦‚æœè€ vnode æ•°ç»„çš„å¼€å§‹ç´¢å¼•å¤§äºç»“æŸç´¢å¼•ï¼Œè¯´æ˜æ–° node æ•°ç»„é•¿åº¦å¤§äºè€ vnode æ•°ç»„ï¼Œæ‰§è¡Œ addVnodes æ–¹æ³•æ·»åŠ è¿™äº›æ–° vnode åˆ° DOM ä¸­

```js
if (oldStartIdx > oldEndIdx) {
  refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
  addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
}
```

> å¦‚æœè€ vnode æ•°ç»„çš„å¼€å§‹ç´¢å¼•å°äºç»“æŸç´¢å¼•ï¼Œè¯´æ˜è€ node æ•°ç»„é•¿åº¦å¤§äºæ–° vnode æ•°ç»„ï¼Œæ‰§è¡Œ removeVnodes æ–¹æ³•ä» DOM ä¸­ç§»é™¤è€ vnode æ•°ç»„ä¸­å¤šä½™çš„ vnode

```js
else if (newStartIdx > newEndIdx) {
  removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
}
```

### æ€»ç»“

ç»è¿‡ä¸Šé¢çš„ä»£ç è§£ææˆ‘ä»¬çŸ¥é“ vue çš„ diff å¯¹é»˜è®¤çš„ diff æ‰§è¡Œäº†ä¼˜åŒ–ï¼ŒæŸ¥æ‰¾çš„åŒä¸€çº§çš„èŠ‚ç‚¹é€šè¿‡å”¯ä¸€çš„ key å»åŒºåˆ†ã€‚å¦‚æœèŠ‚ç‚¹ç±»å‹ç›¸åŒé‡æ–°è®¾ç½®è¯¥èŠ‚ç‚¹çš„å±æ€§ï¼Œç›´æ¥æ›´æ–°ã€‚å¦‚æœä¸åŒï¼Œç›´æ¥å¹²æ‰å‰é¢çš„èŠ‚ç‚¹ï¼Œåˆ›å»ºå¹¶æ’å…¥æ–°çš„èŠ‚ç‚¹ï¼Œä¸å†æ¯”è¾ƒè¿™ä¸ªèŠ‚ç‚¹ä»¥åçš„å­èŠ‚ç‚¹ã€‚è€Œä¸æ˜¯åŒä¸€çº§åˆ«æ¯ä¸€ä¸ªå»æ¯”è¾ƒå¹¶æ›´æ–°æ›¿æ¢ã€‚å¦‚ä¸‹å›¾
<img src="/assets/vue-dom-diff08.png">

å¦‚ä¸Šå›¾æˆ‘ä»¬å¸Œæœ›åœ¨ A å’Œ B ä¹‹é—´åŠ ä¸€ä¸ª Fï¼Œé‚£é»˜è®¤çš„ diff ç®—æ³•æ˜¯è¿™æ ·çš„
<img src="/assets/vue-dom-diff09.png">

vue é€šè¿‡æ¯ä¸€ä¸ªèŠ‚ç‚¹çš„ key æ ‡è¯†ç¬¦æ˜¯è¿™æ ·çš„
<img src="/assets/vue-dom-diff10.png">

ä¸‹é¢æˆ‘ä»¬é€šè¿‡ ä¸€å¼ å›¾æ¥å¤§è‡´æ€»ç»“ patchVnode çš„æµç¨‹
<img src="/assets/vue-dom-diff11.png">
